{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Volto's developer documentation! # Volto is a React-based frontend for the Plone CMS . It will become the default UI for the upcoming Plone 6 release. Although it hasn't reached yet full parity with Plone \"classic\" UI, Volto provides a very attractive proposition to its early adopters: integration with the modern frontend development world, access to the huge ecosystem of React libraries and addons and not least, open Plone as a development platform for non-Plone trained programmers. Thanks to the use of the Plone API framework, it is fully compatible with Plone's Dexterity content type framework (and even the older Archetypes framework). But its power comes from the innovative Pastanaga Editor, which replaces the typical richtext editing experience provided by the TinyMCE editor with a streamlined Mosaic-like editor based on \"blocks\". Thanks to their simplicity and easy access to advanced frontend integration, the Volto blocks can provide a fast development experience that reduces developer frustration and improves end-user experience. To start developing a new Volto project you should have minimal React and modern Javascript knowledge. Follow the Getting started guide to bootstrap a new Volto project and start hacking!","title":"Welcome to Volto's developer documentation!"},{"location":"#welcome-to-voltos-developer-documentation","text":"Volto is a React-based frontend for the Plone CMS . It will become the default UI for the upcoming Plone 6 release. Although it hasn't reached yet full parity with Plone \"classic\" UI, Volto provides a very attractive proposition to its early adopters: integration with the modern frontend development world, access to the huge ecosystem of React libraries and addons and not least, open Plone as a development platform for non-Plone trained programmers. Thanks to the use of the Plone API framework, it is fully compatible with Plone's Dexterity content type framework (and even the older Archetypes framework). But its power comes from the innovative Pastanaga Editor, which replaces the typical richtext editing experience provided by the TinyMCE editor with a streamlined Mosaic-like editor based on \"blocks\". Thanks to their simplicity and easy access to advanced frontend integration, the Volto blocks can provide a fast development experience that reduces developer frustration and improves end-user experience. To start developing a new Volto project you should have minimal React and modern Javascript knowledge. Follow the Getting started guide to bootstrap a new Volto project and start hacking!","title":"Welcome to Volto's developer documentation!"},{"location":"cheatsheet/","text":"Cheatsheet # https://python-markdown.github.io/extensions/ https://facelessuser.github.io/pymdown-extensions/extensions/ Admonition Note You should note that the title will be automatically capitalized. Don't try this at home ... This is an admonition box without a title. This is a tip This is an admonition box without a title. This is a check This is an admonition box without a title. This is a cite This is an admonition box without a title. This is a question This is an admonition box without a title. This is a example This is an admonition box without a title. This is a warning This is an admonition box without a title. This is a bug This is an admonition box without a title. Magic link https://volto.kitconcept.com @sneridagh /** * Render method. * @method render * @returns {string} Markup for the component. */ render () { return ( this . props . messages && ( < Container className = \"messages\" > { map ( this . props . messages , ( message , index ) => ( < Message key = { message . id } value = { index } onDismiss = { this . onDismiss } error = { message . level === 'error' } success = { message . level === 'success' } warning = { message . level === 'warning' } info = { message . level === 'info' } header = { message . title } content = { message . body } /> ))} </ Container > ) ); } ); def asdas : \"\"\" \"\"\" Tab 1 Markdown content . Multiple paragraphs. Tab 2 More Markdown content . list item a list item b Task List item 1 item A item B more text item a item b item c item C item 2 item 3 Open styled details Nested details! And more content again. asdasd Content. Warning Content.","title":"Cheatsheet"},{"location":"cheatsheet/#cheatsheet","text":"https://python-markdown.github.io/extensions/ https://facelessuser.github.io/pymdown-extensions/extensions/ Admonition Note You should note that the title will be automatically capitalized. Don't try this at home ... This is an admonition box without a title. This is a tip This is an admonition box without a title. This is a check This is an admonition box without a title. This is a cite This is an admonition box without a title. This is a question This is an admonition box without a title. This is a example This is an admonition box without a title. This is a warning This is an admonition box without a title. This is a bug This is an admonition box without a title. Magic link https://volto.kitconcept.com @sneridagh /** * Render method. * @method render * @returns {string} Markup for the component. */ render () { return ( this . props . messages && ( < Container className = \"messages\" > { map ( this . props . messages , ( message , index ) => ( < Message key = { message . id } value = { index } onDismiss = { this . onDismiss } error = { message . level === 'error' } success = { message . level === 'success' } warning = { message . level === 'warning' } info = { message . level === 'info' } header = { message . title } content = { message . body } /> ))} </ Container > ) ); } ); def asdas : \"\"\" \"\"\" Tab 1 Markdown content . Multiple paragraphs. Tab 2 More Markdown content . list item a list item b Task List item 1 item A item B more text item a item b item c item C item 2 item 3 Open styled details Nested details! And more content again. asdasd Content. Warning Content.","title":"Cheatsheet"},{"location":"ie11compat/","text":"IE11 compatibility # There are some caveats if we still want to target IE11 as supported browser. Version pinning # These package versions should be pinned to this especific versions, unless their code or dependencies have some es6 only compatible, because their maintainers mainly target the node world. \"query-string\": \"4.1.0\" \"superagent\": \"3.8.2\" Polyfills # Then in the project that should target it, these changes are required: add as a dependency @babel/polyfill . yarn add @babel/polyfill and in src/client.jsx : import '@babel/polyfill' ; Note See https://babeljs.io/docs/en/babel-polyfill for more updated information babel-env # Razzle supports @babel/preset-env , that supports including browserlist in package.json . So you can add this to package.json : \"browserslist\" : [ \"last 2 version\" , \"IE 11\" ] , This supports the query specific DSL for browserlist targeting the browsers that you need to add. Pre-transpiling # Some packages in node_modules are ES6 only, for some older browsers, you might want to add a pre (or post) transpiling. There's a script pre-build-transpiling.js (Volto root folder) that might help you with it. Also this command line might help: ./node_modules/.bin/babel --presets=\"@babel/env\" XXX --out-dir XXX","title":"IE11 compatibility"},{"location":"ie11compat/#ie11-compatibility","text":"There are some caveats if we still want to target IE11 as supported browser.","title":"IE11 compatibility"},{"location":"ie11compat/#version-pinning","text":"These package versions should be pinned to this especific versions, unless their code or dependencies have some es6 only compatible, because their maintainers mainly target the node world. \"query-string\": \"4.1.0\" \"superagent\": \"3.8.2\"","title":"Version pinning"},{"location":"ie11compat/#polyfills","text":"Then in the project that should target it, these changes are required: add as a dependency @babel/polyfill . yarn add @babel/polyfill and in src/client.jsx : import '@babel/polyfill' ; Note See https://babeljs.io/docs/en/babel-polyfill for more updated information","title":"Polyfills"},{"location":"ie11compat/#babel-env","text":"Razzle supports @babel/preset-env , that supports including browserlist in package.json . So you can add this to package.json : \"browserslist\" : [ \"last 2 version\" , \"IE 11\" ] , This supports the query specific DSL for browserlist targeting the browsers that you need to add.","title":"babel-env"},{"location":"ie11compat/#pre-transpiling","text":"Some packages in node_modules are ES6 only, for some older browsers, you might want to add a pre (or post) transpiling. There's a script pre-build-transpiling.js (Volto root folder) that might help you with it. Also this command line might help: ./node_modules/.bin/babel --presets=\"@babel/env\" XXX --out-dir XXX","title":"Pre-transpiling"},{"location":"releases/","text":"Releases # What you can expect from Volto releases and the Volto release management. Volto uses Semantic Versioning to communicate bugfixes, new features, and breaking changes. It supports Plone 5.2 on Python 3 and LTS versions of Node (10, 12 and 14 as the time of writing (Nov'2020)). Semantic Versioning # Volto uses Semantic Versioning to communicate what users and developers can expect from a release. We use a three-digits version scheme (e.g. 4.2.0 ) following the Breaking-Feature-Bugfix naming convention. Breaking (or Major release) # A breaking release indicates a breaking change that might break an application or third-party add-on that relies on Volto, e.g. 4.2.0 -> 5.0.0 For every breaking release, a detailed documentation of what in a breaking change release can be found in our upgrade guide . We sometimes might want to indicate a major Feature # A feature release indicates that a new feature has been added to Volto in a non-breaking fashion, e.g.: 4.2.0 -> 4.3.0 You do not have to expect any breaking changes from such a release. Though, it can happen that the user interface changed due to a new feature that has been added. Bugfix # A bugfix release indicates one or more bugs in Volto have been fixed, e.g.: 4.2.0 -> 4.2.1 You do not have to expect any breaking changes or UX/UI changes from such a release. It just fixed a bug. Plone / Plone REST API # Volto relies on Plone (core) and Plone REST API . We will always support the latest major Plone Release (currently Plone 5.2) that ships with Plone REST API. Volto should work on old Plone versions as well since Plone REST API supports Plone back to version 4.3 (including Archetypes). Though, we do not actively support versions or test Plone versions that have been released long before Volto existed. NodeJS # Volto always supports only LTS versions of NodeJS .","title":"Releases"},{"location":"releases/#releases","text":"What you can expect from Volto releases and the Volto release management. Volto uses Semantic Versioning to communicate bugfixes, new features, and breaking changes. It supports Plone 5.2 on Python 3 and LTS versions of Node (10, 12 and 14 as the time of writing (Nov'2020)).","title":"Releases"},{"location":"releases/#semantic-versioning","text":"Volto uses Semantic Versioning to communicate what users and developers can expect from a release. We use a three-digits version scheme (e.g. 4.2.0 ) following the Breaking-Feature-Bugfix naming convention.","title":"Semantic Versioning"},{"location":"releases/#breaking-or-major-release","text":"A breaking release indicates a breaking change that might break an application or third-party add-on that relies on Volto, e.g. 4.2.0 -> 5.0.0 For every breaking release, a detailed documentation of what in a breaking change release can be found in our upgrade guide . We sometimes might want to indicate a major","title":"Breaking (or Major release)"},{"location":"releases/#feature","text":"A feature release indicates that a new feature has been added to Volto in a non-breaking fashion, e.g.: 4.2.0 -> 4.3.0 You do not have to expect any breaking changes from such a release. Though, it can happen that the user interface changed due to a new feature that has been added.","title":"Feature"},{"location":"releases/#bugfix","text":"A bugfix release indicates one or more bugs in Volto have been fixed, e.g.: 4.2.0 -> 4.2.1 You do not have to expect any breaking changes or UX/UI changes from such a release. It just fixed a bug.","title":"Bugfix"},{"location":"releases/#plone-plone-rest-api","text":"Volto relies on Plone (core) and Plone REST API . We will always support the latest major Plone Release (currently Plone 5.2) that ships with Plone REST API. Volto should work on old Plone versions as well since Plone REST API supports Plone back to version 4.3 (including Archetypes). Though, we do not actively support versions or test Plone versions that have been released long before Volto existed.","title":"Plone / Plone REST API"},{"location":"releases/#nodejs","text":"Volto always supports only LTS versions of NodeJS .","title":"NodeJS"},{"location":"addons/","text":"Volto addons # There are several advanced scenarios where we might want to have more control and flexibility beyond using the plain Volto project to build a site. We can build Volto add-on products and make them available as generic Javascript packages that can be included in any Volto project. By doing so we can provide code and component reutilization across projects and, of course, benefit from open source collaboration. The addon can be published to an NPM registry or directly installed from github by Yarn. By using mrs-develop , it's possible to have a workflow similar to zc.buildout's mr.developer, where you can \"checkout\" an addon for development. An addon can be almost anything that a Volto project can be. They can: provide additional views and blocks override or extend Volto's builtin views, blocks, settings shadow (customize) Volto's (or another addon's) modules register custom routes provide custom Redux actions and reducers register custom Express middleware for Volto's server process tweak Volto's webpak configuration, load custom Razzle and Webpack plugins even provide a custom theme, just like a regular Volto project does. Configuring a Volto project to use an addon # You can install a Volto addon just like any other JS package: yarn add name-of-addon If the addon is not published on NPM, you can retrieve it directly from Github: yarn add collective/volto-dropdownmenu Next, you'll need to add the addon (identified by its JS package name) to the addons key of your Volto project's package.json . More details in the next section. Loading addon configuration # As a convenience, an addon can export configuration functions that can mutate, in-place, the overall ~/config registry. An addon can export multiple configurations methods, making it possible to selectively choose which specific addon functionality you want to load. In your Volto project's package.json you can allow the addon to alter the global configuration by adding, in the addons key, a list of volto addon package names, like: { \"name\" : \"my-nice-volto-project\" , ... \"addons\" : [ \"acme-volto-foo-addon\" , \"@plone/some-addon\" , \"collective-another-volto-addon\" ], ... } Warning Adding the addon package to the addons key is obligatory! It allows Volto to treat that package properly and provide it with BabelJS language features. It is the equivalent of including a Python egg to the zcml section of zc.buildout. Some addons might choose to allow the Volto project to selectively load some of their configuration, so they may offer additional configuration functions, which you can load by overloading the addon name in the addons package.json key, like so: { \"name\" : \"my-nice-volto-project\" , ... \"addons\" : [ \"acme-volto-foo-addon:loadOptionalBlocks,overrideSomeDefaultBlock\" , \"volto-ga\" ], } Info The additional comma-separated names should be exported from the addon package's index.js . The main configuration function should be exported as the default. An addon's default configuration method will always be loaded. If for some reason, you want to manually load the addon, you could always do, in your project's config.js module: import loadExampleAddon , { enableOptionalBlocks } from 'volto-example-addon' ; import * as voltoConfig from '@plone/volto/config' ; const config = enableOptionalBlocks ( loadExampleAddon ( voltoConfig )); export blocks = { ... config . blocks , } ... As this is a common operation, Volto provides a helper method for this: import { applyConfig } from '@plone/volto/helpers'; import * as voltoConfig from '@plone/volto/config'; const config = applyConfig([ enableOptionalBlocks, loadExampleAddon ], voltoConfig); export blocks = { ...config.blocks, } The applyConfig helper ensures that each configuration methods returns the config object, avoiding odd and hard to track errors when developing addons. Creating addons # Volto addon packages are just CommonJS packages. The only requirement is that they point the main key of their package.json to a module that exports, as a default function that acts as a Volto configuration loader. Although you could simply use npm init to generate an addon initial code, we now have a nice Yeoman-based generator that you can use: npm install -g @plone/generator-volto yo @plone/volto:addon [<addonName>] [options] Volto will automatically provide aliases for your (unreleased) package, so that once you've released it, you don't need to change import paths, since you can use the final ones from the very beginning. This means that you can use imports such as import { Something } from '@plone/my-volto-addon' without any extra configuration. Use mrs-developer to manage the development cycle # Add mrs-developer dependency and related script # Eric Brehault ported this amazing Python tool, which provides a way to pull a package from git and set it up as a dependency for the current project codebase. To facilitate addon development lifecycle we recommend using mrs-developer . By doing this, you can develop both the project and the add-on product as if they were both part of the current codebase. Once the add-on development is done, you can publish the package to an npm repository. $ yarn add mrs-developer Then, in package.json : \"scripts\" : { \"develop\" : \"missdev --config=jsconfig.json --output=addons\" , } We can configure mrs-developer to use any directory that you want. Here we are telling it to create the directory src/addons and put the packages managed by mrs-developer inside. mrs.developer.json # This is the configuration file that instructs mrs-developer from where it has to pull the packages. So, create mrs.developer.json and add: { \"acme-volto-foo-addon\" : { \"package\" : \"@acme/volto-foo-addon\" , \"url\" : \"git@github.com:acme/my-volto-addon.git\" , \"path\" : \"src\" } } Then run: yarn develop Now the addon is found in src/addons/ . Info package property is optional, set it up only if your package has a scope. src is required if the content of your addon is located in the src directory (but, as that is the convention recommended for all Volto add-on packages, you will always include it) If you want to know more about mrs-developer config options, please refer to its npm page . jsconfig.json # mrs-developer automatically creates this file for you, but if you choose not to use mrs-developer, you'll have to add something like this to your jsconfig.json file in the Volto project root: { \"compilerOptions\" : { \"paths\" : { \"acme-volto-foo-addon\" : [ \"addons/acme-volto-foo-addon/src\" ] }, \"baseUrl\" : \"src\" } } Warning Please note that both paths and baseUrl are required to match your project layout. Tip You should use the src path inside your package and point the main key in package.json to the index.js file in src/index.js . Customizations # Addon packages can include customization folders, just like the Volto projects. The customizations are resolved in the order: addons (as sorted in the addons key of your project's package.json ) then the customizations in the Volto project, last one wins. Tip See the Advanced customization scenarios section on how to enhance this pattern and how to include customizations inside addons. Providing addon configuration # The default export of your addon main index.js file should be a function with the signature config => config . That is, it should take the global configuration object and return it, possibly mutated or changed. So your main index.js will look like: export default function applyConfig ( config ) { config . blocks . blocksConfig . faq_viewer = { id : 'faq_viewer' , title : 'FAQ Viewer' , edit : FAQBlockEdit , view : FAQBlockView , icon : chartIcon , group : 'common' , restricted : false , mostUsed : true , sidebarTab : 1 , security : { addPermission : [], view : [], }, }; return config ; } And the package.json file of your addon: { \"main\" : \"src/index.js\" , } Warning An addon's default configuration method will always be loaded. Multiple addon configurations # You can export additional configuration functions from your addon's main index.js . import applyConfig , { loadOptionalBlocks , overrideSomeDefaultBlock } from './config' ; export { loadOptionalBlocks , overrideSomeDefaultBlock }; export default applyConfig ; Add third-party dependencies to your addon # If you're developing the addon and you wish to add an external dependency, you'll have to switch your project to be a Yarn Workspaces root . So you'll need to add, in your Volto project's package.json : \"private\": true, \"workspaces\": [], Then populate the workspaces key with the path to your development addons: \"workspaces\": [ \"src/addons/my-volto-addon\" ] You'll have to manage the addon dependencies via the workspace root (your Volto project). For example, to add a new dependency: yarn workspace @plone/my-volto-addon add some-third-party-package You can run yarn workspaces info to see a list of workspaces defined. In case you want to add new dependencies to the Volto project, now you'll have to run the yarn add command with the -W switch: yarn add -W some-dependency Testing addons # We should let jest know about our aliases and make them available to it to resolve them, so in package.json : \"jest\" : { \"moduleNameMapper\" : { \"@plone/volto/(.*)$\" : \"<rootDir>/node_modules/@plone/volto/src/$1\" , \"@package/(.*)$\" : \"<rootDir>/src/$1\" , \"@plone/some-volto-addon/(.*)$\" : \"<rootDir>/src/addons/@plone/some-volto-addon/src/$1\" , 'my-volto-addon/(.*)$': '<rootDir>/src/addons/my-volto-addon/src/$1', \"~/(.*)$\" : \"<rootDir>/src/$1\" }, Tip We're in the process of moving the default scaffolding generators to provide a jest.config.js file in Volto, making this step unneeded. You can use yarn test src/addons/addon-name to run tests. Code linting # If you have generated your Volto project recently (after the summer of 2020), you don't have to do anything to have automatic integration with ESLint, otherwise make sure to upgrade your project's .eslintrc to the .eslintrc.js version, according to the Upgrade Guide .","title":"Introduction"},{"location":"addons/#volto-addons","text":"There are several advanced scenarios where we might want to have more control and flexibility beyond using the plain Volto project to build a site. We can build Volto add-on products and make them available as generic Javascript packages that can be included in any Volto project. By doing so we can provide code and component reutilization across projects and, of course, benefit from open source collaboration. The addon can be published to an NPM registry or directly installed from github by Yarn. By using mrs-develop , it's possible to have a workflow similar to zc.buildout's mr.developer, where you can \"checkout\" an addon for development. An addon can be almost anything that a Volto project can be. They can: provide additional views and blocks override or extend Volto's builtin views, blocks, settings shadow (customize) Volto's (or another addon's) modules register custom routes provide custom Redux actions and reducers register custom Express middleware for Volto's server process tweak Volto's webpak configuration, load custom Razzle and Webpack plugins even provide a custom theme, just like a regular Volto project does.","title":"Volto addons"},{"location":"addons/#configuring-a-volto-project-to-use-an-addon","text":"You can install a Volto addon just like any other JS package: yarn add name-of-addon If the addon is not published on NPM, you can retrieve it directly from Github: yarn add collective/volto-dropdownmenu Next, you'll need to add the addon (identified by its JS package name) to the addons key of your Volto project's package.json . More details in the next section.","title":"Configuring a Volto project to use an addon"},{"location":"addons/#loading-addon-configuration","text":"As a convenience, an addon can export configuration functions that can mutate, in-place, the overall ~/config registry. An addon can export multiple configurations methods, making it possible to selectively choose which specific addon functionality you want to load. In your Volto project's package.json you can allow the addon to alter the global configuration by adding, in the addons key, a list of volto addon package names, like: { \"name\" : \"my-nice-volto-project\" , ... \"addons\" : [ \"acme-volto-foo-addon\" , \"@plone/some-addon\" , \"collective-another-volto-addon\" ], ... } Warning Adding the addon package to the addons key is obligatory! It allows Volto to treat that package properly and provide it with BabelJS language features. It is the equivalent of including a Python egg to the zcml section of zc.buildout. Some addons might choose to allow the Volto project to selectively load some of their configuration, so they may offer additional configuration functions, which you can load by overloading the addon name in the addons package.json key, like so: { \"name\" : \"my-nice-volto-project\" , ... \"addons\" : [ \"acme-volto-foo-addon:loadOptionalBlocks,overrideSomeDefaultBlock\" , \"volto-ga\" ], } Info The additional comma-separated names should be exported from the addon package's index.js . The main configuration function should be exported as the default. An addon's default configuration method will always be loaded. If for some reason, you want to manually load the addon, you could always do, in your project's config.js module: import loadExampleAddon , { enableOptionalBlocks } from 'volto-example-addon' ; import * as voltoConfig from '@plone/volto/config' ; const config = enableOptionalBlocks ( loadExampleAddon ( voltoConfig )); export blocks = { ... config . blocks , } ... As this is a common operation, Volto provides a helper method for this: import { applyConfig } from '@plone/volto/helpers'; import * as voltoConfig from '@plone/volto/config'; const config = applyConfig([ enableOptionalBlocks, loadExampleAddon ], voltoConfig); export blocks = { ...config.blocks, } The applyConfig helper ensures that each configuration methods returns the config object, avoiding odd and hard to track errors when developing addons.","title":"Loading addon configuration"},{"location":"addons/#creating-addons","text":"Volto addon packages are just CommonJS packages. The only requirement is that they point the main key of their package.json to a module that exports, as a default function that acts as a Volto configuration loader. Although you could simply use npm init to generate an addon initial code, we now have a nice Yeoman-based generator that you can use: npm install -g @plone/generator-volto yo @plone/volto:addon [<addonName>] [options] Volto will automatically provide aliases for your (unreleased) package, so that once you've released it, you don't need to change import paths, since you can use the final ones from the very beginning. This means that you can use imports such as import { Something } from '@plone/my-volto-addon' without any extra configuration.","title":"Creating addons"},{"location":"addons/#use-mrs-developer-to-manage-the-development-cycle","text":"","title":"Use mrs-developer to manage the development cycle"},{"location":"addons/#add-mrs-developer-dependency-and-related-script","text":"Eric Brehault ported this amazing Python tool, which provides a way to pull a package from git and set it up as a dependency for the current project codebase. To facilitate addon development lifecycle we recommend using mrs-developer . By doing this, you can develop both the project and the add-on product as if they were both part of the current codebase. Once the add-on development is done, you can publish the package to an npm repository. $ yarn add mrs-developer Then, in package.json : \"scripts\" : { \"develop\" : \"missdev --config=jsconfig.json --output=addons\" , } We can configure mrs-developer to use any directory that you want. Here we are telling it to create the directory src/addons and put the packages managed by mrs-developer inside.","title":"Add mrs-developer dependency and related script"},{"location":"addons/#mrsdeveloperjson","text":"This is the configuration file that instructs mrs-developer from where it has to pull the packages. So, create mrs.developer.json and add: { \"acme-volto-foo-addon\" : { \"package\" : \"@acme/volto-foo-addon\" , \"url\" : \"git@github.com:acme/my-volto-addon.git\" , \"path\" : \"src\" } } Then run: yarn develop Now the addon is found in src/addons/ . Info package property is optional, set it up only if your package has a scope. src is required if the content of your addon is located in the src directory (but, as that is the convention recommended for all Volto add-on packages, you will always include it) If you want to know more about mrs-developer config options, please refer to its npm page .","title":"mrs.developer.json"},{"location":"addons/#jsconfigjson","text":"mrs-developer automatically creates this file for you, but if you choose not to use mrs-developer, you'll have to add something like this to your jsconfig.json file in the Volto project root: { \"compilerOptions\" : { \"paths\" : { \"acme-volto-foo-addon\" : [ \"addons/acme-volto-foo-addon/src\" ] }, \"baseUrl\" : \"src\" } } Warning Please note that both paths and baseUrl are required to match your project layout. Tip You should use the src path inside your package and point the main key in package.json to the index.js file in src/index.js .","title":"jsconfig.json"},{"location":"addons/#customizations","text":"Addon packages can include customization folders, just like the Volto projects. The customizations are resolved in the order: addons (as sorted in the addons key of your project's package.json ) then the customizations in the Volto project, last one wins. Tip See the Advanced customization scenarios section on how to enhance this pattern and how to include customizations inside addons.","title":"Customizations"},{"location":"addons/#providing-addon-configuration","text":"The default export of your addon main index.js file should be a function with the signature config => config . That is, it should take the global configuration object and return it, possibly mutated or changed. So your main index.js will look like: export default function applyConfig ( config ) { config . blocks . blocksConfig . faq_viewer = { id : 'faq_viewer' , title : 'FAQ Viewer' , edit : FAQBlockEdit , view : FAQBlockView , icon : chartIcon , group : 'common' , restricted : false , mostUsed : true , sidebarTab : 1 , security : { addPermission : [], view : [], }, }; return config ; } And the package.json file of your addon: { \"main\" : \"src/index.js\" , } Warning An addon's default configuration method will always be loaded.","title":"Providing addon configuration"},{"location":"addons/#multiple-addon-configurations","text":"You can export additional configuration functions from your addon's main index.js . import applyConfig , { loadOptionalBlocks , overrideSomeDefaultBlock } from './config' ; export { loadOptionalBlocks , overrideSomeDefaultBlock }; export default applyConfig ;","title":"Multiple addon configurations"},{"location":"addons/#add-third-party-dependencies-to-your-addon","text":"If you're developing the addon and you wish to add an external dependency, you'll have to switch your project to be a Yarn Workspaces root . So you'll need to add, in your Volto project's package.json : \"private\": true, \"workspaces\": [], Then populate the workspaces key with the path to your development addons: \"workspaces\": [ \"src/addons/my-volto-addon\" ] You'll have to manage the addon dependencies via the workspace root (your Volto project). For example, to add a new dependency: yarn workspace @plone/my-volto-addon add some-third-party-package You can run yarn workspaces info to see a list of workspaces defined. In case you want to add new dependencies to the Volto project, now you'll have to run the yarn add command with the -W switch: yarn add -W some-dependency","title":"Add third-party dependencies to your addon"},{"location":"addons/#testing-addons","text":"We should let jest know about our aliases and make them available to it to resolve them, so in package.json : \"jest\" : { \"moduleNameMapper\" : { \"@plone/volto/(.*)$\" : \"<rootDir>/node_modules/@plone/volto/src/$1\" , \"@package/(.*)$\" : \"<rootDir>/src/$1\" , \"@plone/some-volto-addon/(.*)$\" : \"<rootDir>/src/addons/@plone/some-volto-addon/src/$1\" , 'my-volto-addon/(.*)$': '<rootDir>/src/addons/my-volto-addon/src/$1', \"~/(.*)$\" : \"<rootDir>/src/$1\" }, Tip We're in the process of moving the default scaffolding generators to provide a jest.config.js file in Volto, making this step unneeded. You can use yarn test src/addons/addon-name to run tests.","title":"Testing addons"},{"location":"addons/#code-linting","text":"If you have generated your Volto project recently (after the summer of 2020), you don't have to do anything to have automatic integration with ESLint, otherwise make sure to upgrade your project's .eslintrc to the .eslintrc.js version, according to the Upgrade Guide .","title":"Code linting"},{"location":"addons/best-practices/","text":"Best practices for addons # Although the addon framework is relatively new in Volto's world, there are quite a few generic addons that can be used in any Volto project. Based on the experience gained developing some of these addons, we recommend that you follow (no need for strictness, of course) these rough guidelines: Integrate your addon with Volto's addon framework # Just like Plone addons provide some features by default, Volto addons should register some features by default. For example, if your addon provides widgets, register the most basic configuration of that widget with a name that can be used. On more complicated cases, see if you can structure your code to use the settings registry of ~/config , or stash your configuration in your block registration, for example. As an example: let's say we're building a Color Picker widget and we want to provide a palette of colors from which to choose. The widget should integrate with a default settings.colorWidgetPalette , which would be a list of colors. And of course, also provide a widget factory so it can be used to create multiple instances of that color widget with custom color palettes. Provide additional configuration # An addon can ship with multiple Volto configuration loaders. This makes it possible to provide configuration methods for demo purposes, for example, or to ship with a default \"shallow\" integration, then provide another separate configuration loader for a deeper integration. Avoid shadowing Volto files # This rule is meant to be broken. If you find that you need to customize a particular file from Volto and you have multiple projects, better to create an addon that holds that customized file, so that you have a single place to maintain that \"file fork\", but otherwise it's a good idea to avoid shipping generic addons with Volto customizations. Make sure to include this information as a warning in your addon description! See if your use case is generic enough, maybe Volto needs to be extended to cover that use case, directly in core. Minimal documentation # Deadlines can be rough and documentation tends to be pushed as last priority, but please add a minimal Readme with a couple of lines and, most importantly, a screenshot. Ideally, the Readme should also include install instructions and details on any possible settings. Testing the addon # It is not easy, right now, to ship an addon with a self-bootstraping and testing framework. But you can create a separate minimal Volto project that can hold the Cypress integration tests and trigger the CI tests. Include in collective/awesome-volto # Even if you think your addon is not generic or it's tricky to integrate, please consider including your addon in the collective/awesome-volto addons list. This provides visibility to your addon but also further solidifies Volto's possition in our Plone community.","title":"Best practices"},{"location":"addons/best-practices/#best-practices-for-addons","text":"Although the addon framework is relatively new in Volto's world, there are quite a few generic addons that can be used in any Volto project. Based on the experience gained developing some of these addons, we recommend that you follow (no need for strictness, of course) these rough guidelines:","title":"Best practices for addons"},{"location":"addons/best-practices/#integrate-your-addon-with-voltos-addon-framework","text":"Just like Plone addons provide some features by default, Volto addons should register some features by default. For example, if your addon provides widgets, register the most basic configuration of that widget with a name that can be used. On more complicated cases, see if you can structure your code to use the settings registry of ~/config , or stash your configuration in your block registration, for example. As an example: let's say we're building a Color Picker widget and we want to provide a palette of colors from which to choose. The widget should integrate with a default settings.colorWidgetPalette , which would be a list of colors. And of course, also provide a widget factory so it can be used to create multiple instances of that color widget with custom color palettes.","title":"Integrate your addon with Volto's addon framework"},{"location":"addons/best-practices/#provide-additional-configuration","text":"An addon can ship with multiple Volto configuration loaders. This makes it possible to provide configuration methods for demo purposes, for example, or to ship with a default \"shallow\" integration, then provide another separate configuration loader for a deeper integration.","title":"Provide additional configuration"},{"location":"addons/best-practices/#avoid-shadowing-volto-files","text":"This rule is meant to be broken. If you find that you need to customize a particular file from Volto and you have multiple projects, better to create an addon that holds that customized file, so that you have a single place to maintain that \"file fork\", but otherwise it's a good idea to avoid shipping generic addons with Volto customizations. Make sure to include this information as a warning in your addon description! See if your use case is generic enough, maybe Volto needs to be extended to cover that use case, directly in core.","title":"Avoid shadowing Volto files"},{"location":"addons/best-practices/#minimal-documentation","text":"Deadlines can be rough and documentation tends to be pushed as last priority, but please add a minimal Readme with a couple of lines and, most importantly, a screenshot. Ideally, the Readme should also include install instructions and details on any possible settings.","title":"Minimal documentation"},{"location":"addons/best-practices/#testing-the-addon","text":"It is not easy, right now, to ship an addon with a self-bootstraping and testing framework. But you can create a separate minimal Volto project that can hold the Cypress integration tests and trigger the CI tests.","title":"Testing the addon"},{"location":"addons/best-practices/#include-in-collectiveawesome-volto","text":"Even if you think your addon is not generic or it's tricky to integrate, please consider including your addon in the collective/awesome-volto addons list. This provides visibility to your addon but also further solidifies Volto's possition in our Plone community.","title":"Include in collective/awesome-volto"},{"location":"backend/","text":"Integration with the backend # Plone backend integration # Integration with the Plone CMS is provided by the Plone API framework, namely plone.restapi and its lower-level plone.rest . For details please check the plone.restapi documentation website . Some of the more interesting integration features that you can look up in the plone.restapi documentation: Endpoints : the equivalent of Plone \"views\", these are REST Api endpoints that you can call from the frontend. The response should be in JSON format. You'll use these for any type of interaction with the backend. Content expansions : additional information that can be added to the main response. For example, when fetching \"content\" information, you may want to also include information about the author, so you could write an expand that automatically inserts that information if the ?expand=author is present in the request. It is also possible to create expand elements that will automatically insert their content in the response, without the need for the request parameter. Block transformers : these are named subscribers that can be used to automatically change the information that is sent to the frontend for some of the blocks, but they can also do the opposite, to process the information coming from the frontend (on create or update operations) and change the way the block value is stored in the database. There are multiple use cases for this type of feature, for example to automatically convert incoming links in block values to resolveuid-based links (and to convert them back to absolute URLs when retrieving the block value from the frontend). Search and indexing integration : by providing the right adapters, you can extract searchable text from blocks. Note This section contains pointers for backend integration with Plone. Contributions for the Guillotina backend are needed.","title":"Backend integration"},{"location":"backend/#integration-with-the-backend","text":"","title":"Integration with the backend"},{"location":"backend/#plone-backend-integration","text":"Integration with the Plone CMS is provided by the Plone API framework, namely plone.restapi and its lower-level plone.rest . For details please check the plone.restapi documentation website . Some of the more interesting integration features that you can look up in the plone.restapi documentation: Endpoints : the equivalent of Plone \"views\", these are REST Api endpoints that you can call from the frontend. The response should be in JSON format. You'll use these for any type of interaction with the backend. Content expansions : additional information that can be added to the main response. For example, when fetching \"content\" information, you may want to also include information about the author, so you could write an expand that automatically inserts that information if the ?expand=author is present in the request. It is also possible to create expand elements that will automatically insert their content in the response, without the need for the request parameter. Block transformers : these are named subscribers that can be used to automatically change the information that is sent to the frontend for some of the blocks, but they can also do the opposite, to process the information coming from the frontend (on create or update operations) and change the way the block value is stored in the database. There are multiple use cases for this type of feature, for example to automatically convert incoming links in block values to resolveuid-based links (and to convert them back to absolute URLs when retrieving the block value from the frontend). Search and indexing integration : by providing the right adapters, you can extract searchable text from blocks. Note This section contains pointers for backend integration with Plone. Contributions for the Guillotina backend are needed.","title":"Plone backend integration"},{"location":"blocks/","text":"Blocks # Introduction Anatomy Settings Edit Components","title":"Blocks"},{"location":"blocks/#blocks","text":"Introduction Anatomy Settings Edit Components","title":"Blocks"},{"location":"blocks/anatomy/","text":"Blocks anatomy # Every blocks is composed of an edit ( Edit.jsx ) and a view ( View.jsx ) component. This components can be as simple as a dummy component, no boilerplate is required. This is an example of the Edit.jsx : import React from 'react' ; const Edit = props => { return < div > I ' m the Block edit component ! </ div >; }; export default Edit ; and the View.jsx . import React from 'react' ; const View = props => { return < div > I ' m the Block view component ! </ div >; }; export default View ; Block view component props # The view component of a block receives these props from the Blocks Engine: id - the unique ID for the current block properties - the current content data - the data of the block (stored in the block itself) You can use them to render the view component. Block edit component props # The edit component of a block receives these props from the Blocks Engine: type - the type of the block id - the unique ID for the current block data - the data of the block (stored in the block itself) selected - (Bool) true if the block is currently selected index - the block index order in the list of blocks pathname - the current URL pathname onAddBlock - handler for adding a block in the block list onMutateBlock - handler for mutating a block type into another onChangeBlock - handler for changing the data of that block onSelectBlock - handler for selecting the block onDeleteBlock - handler for deleting the block onFocusPreviousBlock - handler for focusing the previous block in the block list onFocusNextBlock - handler for focusing the next block in the block list handleKeyDown - handler for managing press keys while the block is selected onMoveBlock - handler for moving blocks You can use all these props to render your edit block and model its behavior.","title":"Anatomy"},{"location":"blocks/anatomy/#blocks-anatomy","text":"Every blocks is composed of an edit ( Edit.jsx ) and a view ( View.jsx ) component. This components can be as simple as a dummy component, no boilerplate is required. This is an example of the Edit.jsx : import React from 'react' ; const Edit = props => { return < div > I ' m the Block edit component ! </ div >; }; export default Edit ; and the View.jsx . import React from 'react' ; const View = props => { return < div > I ' m the Block view component ! </ div >; }; export default View ;","title":"Blocks anatomy"},{"location":"blocks/anatomy/#block-view-component-props","text":"The view component of a block receives these props from the Blocks Engine: id - the unique ID for the current block properties - the current content data - the data of the block (stored in the block itself) You can use them to render the view component.","title":"Block view component props"},{"location":"blocks/anatomy/#block-edit-component-props","text":"The edit component of a block receives these props from the Blocks Engine: type - the type of the block id - the unique ID for the current block data - the data of the block (stored in the block itself) selected - (Bool) true if the block is currently selected index - the block index order in the list of blocks pathname - the current URL pathname onAddBlock - handler for adding a block in the block list onMutateBlock - handler for mutating a block type into another onChangeBlock - handler for changing the data of that block onSelectBlock - handler for selecting the block onDeleteBlock - handler for deleting the block onFocusPreviousBlock - handler for focusing the previous block in the block list onFocusNextBlock - handler for focusing the next block in the block list handleKeyDown - handler for managing press keys while the block is selected onMoveBlock - handler for moving blocks You can use all these props to render your edit block and model its behavior.","title":"Block edit component props"},{"location":"blocks/editcomponent/","text":"Blocks - Edit components # The edit component part of a block anatomy is specially different to the view component because they have to support the UX for editing the block. This UX can be very complex depending on the kind of block and the feature that it is trying to provide. The project requirements will tell how far you should go with the UX story of each tile, and how complex it will become. You can use all the props that the edit component is receiving to model the UX for the block and how it will render. See the complete list of props . We have several UI/UX artifacts in order to model our block edit component UX. The sidebar and the object browser are the main ones. Sidebar # We can use the new sidebar when building our blocks' edit components. The sidebar is a new UI asset that is available in Volto 4. You need to instantiate it this way: import { SidebarPortal } from '@plone/volto/components' ; [...] < SidebarPortal selected = { this . props . selected }> ... </ SidebarPortal > Everything that's inside the SidebarPortal component will be rendered in the sidebar. Automated block editing forms # To simplify the task of defining the edit component for a block, the InlineForm component can be used. The block edit component needs to be described by a schema that matches the format used to serialize the content type definitions. The widgets that will be used in rendering the form follow the same algorithm that is used for the regular metadata fields for the content types. As an example of schema, it could look like this: const IframeSchema = { title : 'Embed external content' , fieldsets : [ { id : 'default' , title : 'Default' , fields : [ 'url' , 'align' , 'privacy_statement' , 'privacy_cookie_key' , 'enabled' , ], }, ], properties : { url : { title : 'Embed URL' , }, privacy_statement : { title : 'Privacy statement' , description : 'Short notification text' , widget : 'text' , }, privacy_cookie_key : { title : 'Privacy cookie key' , description : 'Identifies similar external content' , }, enabled : { title : 'Use privacy screen?' , description : 'Enable/disable the privacy protection' , type : 'boolean' , }, }, required : [ 'url' ], }; export default IframeSchema ; To render this form and make it available to the edit component: import schema from './schema' ; import InlineForm from '@plone/volto/components/manage/Form/InlineForm' ; < SidebarPortal selected = { this . props . selected }> < InlineForm schema = { schema } title = { schema . title } onChangeField = {( id , value ) => { this . props . onChangeBlock ( this . props . block , { ... this . props . data , [ id ] : value , }); }} formData = { this . props . data } /> </ SidebarPortal >; Object Browser # Volto 4 has a new object browser component that allows you to select an existing content object from the site. It has the form of an HOC (High Order Component), so you have to wrap the component you want to be able to call the object browser from with it, like this: import withObjectBrowser from '@plone/volto/components/manage/Sidebar/ObjectBrowser' ; [...] export default withObjectBrowser ( MyComponent ) The HOC component withObjectBrowser wraps your component by making available this props: isObjectBrowserOpen - (Bool) tells if the browser is currently open openObjectBrowser - handler for opening the browser closeObjectBrowser - handler for closing the browser By default, it's enabled for all the component tree under the Blocks Editor, so it's available already for all the blocks in edit mode. However, if you need to instantiate it somewhere else, you can do it anyways by wrapping your component with it. Note The default image block in Volto features both the Sidebar and the object browser, take a look at its source code in case you need more context on how they work. openObjectBrowser handler API # If you want to open an ObjectBrowser from your Block, you need to call the openObjectBrowser function you'll find in the props of your block component. This function has this signature: @param {Object} object ObjectBrowser configuration. @param {string} object.mode Quick mode, defaults to `image`. @param {string} object.dataName Name of the block data property to write the selected item. @param {string} object.onSelectItem Function that will be called on item selection. These are some examples on how to use it: // Opens the browser in the `image` mode by default if no config object specified, so it saves the selection in the `url` data property. this . props . openObjectBrowser (); // Opens the browser in the `link` mode, so it saves the selection in the `href` data property. this . props . openObjectBrowser ({ mode : 'link' }); // Opens the browser defining which data property should save the selection using `dataName` this . props . openObjectBrowser ({ dataName : 'myfancydatafield' , }); // Opens the browser defining the function that should be used to save the selection using `onSelectItem` this . props . openObjectBrowser ({ onSelectItem : ( url ) => this . props . onChangeBlock ( this . props . block , { ... this . props . data , myfancydatafield : url , }), }); ObjectBrowserWidget # This widget shows an objectBrowser to find content/contents on site. It is the default widget for vocabulary fields that uses plone.app.vocabularies.Catalog. It works in 3 different mode: image : The field value is an object. The path of selected item is saved in 'url' property of value object. (fieldName: {url:''}) link : The field value is an object. The path of selected item is saved in 'href' property of value object. (fieldName: {href:''}) multiple : The field value is an array of objects. PropDataName vs dataName # dataName is the prop inside data object, used for link and image mode. PropDataName is the name of field wich value is data . It's used for multiple mode. For example: content : { '@id' : 'page-1' , related_pages : [], image : { url : \"\" }, link : { href : \"\" } } if we use object browser widget for fields: related_pages : propDataName is related_pages and dataName is null, image : dataName is url and propDataName is null link : dataName is href and propDataName is null ObjectBrowserWidgetMode() # Returns the component widget with mode passed as argument. The default mode for ObjectBrowserWidget is multiple. If you would like to use this widget with link or image mode as widget field for a specific field id (for example), you could specify in in config.js as: export const widgets = { widgetMapping : { ... widgetMapping , id : { ... widgetMapping . id , my_image_field : ObjectBrowserWidgetMode ( 'image' ), my_link_field : ObjectBrowserWidgetMode ( 'link' ), }, }, default : defaultWidget , }; Selectable types # If selectableTypes is set in widgetOptions.pattern_options , widget allows to select only items that matches types defined in widgetOptions.pattern_options.selectableTypes . < ObjectBrowserWidget ... widgetOptions = {{ pattern_options : { selectableTypes : [ 'News Item' , 'Event' ]}}}> You can also set the selectableTypes from plone when declaring a field for contenttype: form . widget ( 'a_cura_di' , RelatedItemsFieldWidget , ( vocabulary = 'plone.app.vocabularies.Catalog' ), ( pattern_options = { maximumSelectionSize : 1 , selectableTypes : [ 'News Item' , 'Event' ], }), ); MaximumSelectionSize # If maximumSelectionSize is set in widgetOptions.pattern_options , widget allows to select at most the maximumSelectionSize number of items defined in widgetOptions.pattern_options.maximumSelectionSize . < ObjectBrowserWidget ... widgetOptions = {{ pattern_options : { maximumSelectionSize : 2 }}}> You can also set the maximumSelectionSize from plone when declaring a field for contenttype: form . widget ( 'a_cura_di' , RelatedItemsFieldWidget , ( vocabulary = 'plone.app.vocabularies.Catalog' ), ( pattern_options = { maximumSelectionSize : 1 , selectableTypes : [ 'Event' ] }), ); form . widget ( 'notizie_correlate' , RelatedItemsFieldWidget , ( vocabulary = 'plone.app.vocabularies.Catalog' ), ( pattern_options = { maximumSelectionSize : 10 , selectableTypes : [ 'News Item' ], }), );","title":"Edit components"},{"location":"blocks/editcomponent/#blocks-edit-components","text":"The edit component part of a block anatomy is specially different to the view component because they have to support the UX for editing the block. This UX can be very complex depending on the kind of block and the feature that it is trying to provide. The project requirements will tell how far you should go with the UX story of each tile, and how complex it will become. You can use all the props that the edit component is receiving to model the UX for the block and how it will render. See the complete list of props . We have several UI/UX artifacts in order to model our block edit component UX. The sidebar and the object browser are the main ones.","title":"Blocks - Edit components"},{"location":"blocks/editcomponent/#sidebar","text":"We can use the new sidebar when building our blocks' edit components. The sidebar is a new UI asset that is available in Volto 4. You need to instantiate it this way: import { SidebarPortal } from '@plone/volto/components' ; [...] < SidebarPortal selected = { this . props . selected }> ... </ SidebarPortal > Everything that's inside the SidebarPortal component will be rendered in the sidebar.","title":"Sidebar"},{"location":"blocks/editcomponent/#automated-block-editing-forms","text":"To simplify the task of defining the edit component for a block, the InlineForm component can be used. The block edit component needs to be described by a schema that matches the format used to serialize the content type definitions. The widgets that will be used in rendering the form follow the same algorithm that is used for the regular metadata fields for the content types. As an example of schema, it could look like this: const IframeSchema = { title : 'Embed external content' , fieldsets : [ { id : 'default' , title : 'Default' , fields : [ 'url' , 'align' , 'privacy_statement' , 'privacy_cookie_key' , 'enabled' , ], }, ], properties : { url : { title : 'Embed URL' , }, privacy_statement : { title : 'Privacy statement' , description : 'Short notification text' , widget : 'text' , }, privacy_cookie_key : { title : 'Privacy cookie key' , description : 'Identifies similar external content' , }, enabled : { title : 'Use privacy screen?' , description : 'Enable/disable the privacy protection' , type : 'boolean' , }, }, required : [ 'url' ], }; export default IframeSchema ; To render this form and make it available to the edit component: import schema from './schema' ; import InlineForm from '@plone/volto/components/manage/Form/InlineForm' ; < SidebarPortal selected = { this . props . selected }> < InlineForm schema = { schema } title = { schema . title } onChangeField = {( id , value ) => { this . props . onChangeBlock ( this . props . block , { ... this . props . data , [ id ] : value , }); }} formData = { this . props . data } /> </ SidebarPortal >;","title":"Automated block editing forms"},{"location":"blocks/editcomponent/#object-browser","text":"Volto 4 has a new object browser component that allows you to select an existing content object from the site. It has the form of an HOC (High Order Component), so you have to wrap the component you want to be able to call the object browser from with it, like this: import withObjectBrowser from '@plone/volto/components/manage/Sidebar/ObjectBrowser' ; [...] export default withObjectBrowser ( MyComponent ) The HOC component withObjectBrowser wraps your component by making available this props: isObjectBrowserOpen - (Bool) tells if the browser is currently open openObjectBrowser - handler for opening the browser closeObjectBrowser - handler for closing the browser By default, it's enabled for all the component tree under the Blocks Editor, so it's available already for all the blocks in edit mode. However, if you need to instantiate it somewhere else, you can do it anyways by wrapping your component with it. Note The default image block in Volto features both the Sidebar and the object browser, take a look at its source code in case you need more context on how they work.","title":"Object Browser"},{"location":"blocks/editcomponent/#openobjectbrowser-handler-api","text":"If you want to open an ObjectBrowser from your Block, you need to call the openObjectBrowser function you'll find in the props of your block component. This function has this signature: @param {Object} object ObjectBrowser configuration. @param {string} object.mode Quick mode, defaults to `image`. @param {string} object.dataName Name of the block data property to write the selected item. @param {string} object.onSelectItem Function that will be called on item selection. These are some examples on how to use it: // Opens the browser in the `image` mode by default if no config object specified, so it saves the selection in the `url` data property. this . props . openObjectBrowser (); // Opens the browser in the `link` mode, so it saves the selection in the `href` data property. this . props . openObjectBrowser ({ mode : 'link' }); // Opens the browser defining which data property should save the selection using `dataName` this . props . openObjectBrowser ({ dataName : 'myfancydatafield' , }); // Opens the browser defining the function that should be used to save the selection using `onSelectItem` this . props . openObjectBrowser ({ onSelectItem : ( url ) => this . props . onChangeBlock ( this . props . block , { ... this . props . data , myfancydatafield : url , }), });","title":"openObjectBrowser handler API"},{"location":"blocks/editcomponent/#objectbrowserwidget","text":"This widget shows an objectBrowser to find content/contents on site. It is the default widget for vocabulary fields that uses plone.app.vocabularies.Catalog. It works in 3 different mode: image : The field value is an object. The path of selected item is saved in 'url' property of value object. (fieldName: {url:''}) link : The field value is an object. The path of selected item is saved in 'href' property of value object. (fieldName: {href:''}) multiple : The field value is an array of objects.","title":"ObjectBrowserWidget"},{"location":"blocks/editcomponent/#propdataname-vs-dataname","text":"dataName is the prop inside data object, used for link and image mode. PropDataName is the name of field wich value is data . It's used for multiple mode. For example: content : { '@id' : 'page-1' , related_pages : [], image : { url : \"\" }, link : { href : \"\" } } if we use object browser widget for fields: related_pages : propDataName is related_pages and dataName is null, image : dataName is url and propDataName is null link : dataName is href and propDataName is null","title":"PropDataName vs dataName"},{"location":"blocks/editcomponent/#objectbrowserwidgetmode","text":"Returns the component widget with mode passed as argument. The default mode for ObjectBrowserWidget is multiple. If you would like to use this widget with link or image mode as widget field for a specific field id (for example), you could specify in in config.js as: export const widgets = { widgetMapping : { ... widgetMapping , id : { ... widgetMapping . id , my_image_field : ObjectBrowserWidgetMode ( 'image' ), my_link_field : ObjectBrowserWidgetMode ( 'link' ), }, }, default : defaultWidget , };","title":"ObjectBrowserWidgetMode()"},{"location":"blocks/editcomponent/#selectable-types","text":"If selectableTypes is set in widgetOptions.pattern_options , widget allows to select only items that matches types defined in widgetOptions.pattern_options.selectableTypes . < ObjectBrowserWidget ... widgetOptions = {{ pattern_options : { selectableTypes : [ 'News Item' , 'Event' ]}}}> You can also set the selectableTypes from plone when declaring a field for contenttype: form . widget ( 'a_cura_di' , RelatedItemsFieldWidget , ( vocabulary = 'plone.app.vocabularies.Catalog' ), ( pattern_options = { maximumSelectionSize : 1 , selectableTypes : [ 'News Item' , 'Event' ], }), );","title":"Selectable types"},{"location":"blocks/editcomponent/#maximumselectionsize","text":"If maximumSelectionSize is set in widgetOptions.pattern_options , widget allows to select at most the maximumSelectionSize number of items defined in widgetOptions.pattern_options.maximumSelectionSize . < ObjectBrowserWidget ... widgetOptions = {{ pattern_options : { maximumSelectionSize : 2 }}}> You can also set the maximumSelectionSize from plone when declaring a field for contenttype: form . widget ( 'a_cura_di' , RelatedItemsFieldWidget , ( vocabulary = 'plone.app.vocabularies.Catalog' ), ( pattern_options = { maximumSelectionSize : 1 , selectableTypes : [ 'Event' ] }), ); form . widget ( 'notizie_correlate' , RelatedItemsFieldWidget , ( vocabulary = 'plone.app.vocabularies.Catalog' ), ( pattern_options = { maximumSelectionSize : 10 , selectableTypes : [ 'News Item' ], }), );","title":"MaximumSelectionSize"},{"location":"blocks/introduction/","text":"Blocks # Volto features the Pastanaga Editor Engine, allowing you to visually compose a page using blocks. The editor allows you to add, modify, reorder and delete blocks given your requirements. Blocks provide the user the ability to display content in an specific way, although they can also define behavior and have specific features. Blocks are composed of two basic (and required) components: the block edit and view components. By default, Volto ships with the most basic set of blocks: Title, Text, Image, Video, Maps, etc... Note Volto Blocks are not enabled by default in Plone content types, in order to enable this feature, you should enable provided behavior in a per content type basis. The programmatic name of the behavior is volto.blocks , or Blocks in the Behavior tab of the Dexterity Content Types control panel. If you are using the kitconcept.volto package, it sets it up for you for the Document content type. How to manually enable Blocks on a content type # You can enable them on any content type by enabling Blocks behavior provided by plone.restapi . Go to ControlPanel -> Dexterity Content Types , select the content type. Go to Behaviors Select the Blocks behavior Save You can also add the behavior programatically via GenericSetup: <?xml version=\"1.0\"?> <object name= \"LRF\" meta_type= \"Dexterity FTI\" i18n:domain= \"plone\" xmlns:i18n= \"http://xml.zope.org/namespaces/i18n\" > <property name= \"behaviors\" purge= \"false\" > <element value= \"plone.restapi.behaviors.IBlocks\" /> </property> </object> Test that the content type you've just enabled Blocks behavior is working, by creating a new object of that type from Volto.","title":"Introduction"},{"location":"blocks/introduction/#blocks","text":"Volto features the Pastanaga Editor Engine, allowing you to visually compose a page using blocks. The editor allows you to add, modify, reorder and delete blocks given your requirements. Blocks provide the user the ability to display content in an specific way, although they can also define behavior and have specific features. Blocks are composed of two basic (and required) components: the block edit and view components. By default, Volto ships with the most basic set of blocks: Title, Text, Image, Video, Maps, etc... Note Volto Blocks are not enabled by default in Plone content types, in order to enable this feature, you should enable provided behavior in a per content type basis. The programmatic name of the behavior is volto.blocks , or Blocks in the Behavior tab of the Dexterity Content Types control panel. If you are using the kitconcept.volto package, it sets it up for you for the Document content type.","title":"Blocks"},{"location":"blocks/introduction/#how-to-manually-enable-blocks-on-a-content-type","text":"You can enable them on any content type by enabling Blocks behavior provided by plone.restapi . Go to ControlPanel -> Dexterity Content Types , select the content type. Go to Behaviors Select the Blocks behavior Save You can also add the behavior programatically via GenericSetup: <?xml version=\"1.0\"?> <object name= \"LRF\" meta_type= \"Dexterity FTI\" i18n:domain= \"plone\" xmlns:i18n= \"http://xml.zope.org/namespaces/i18n\" > <property name= \"behaviors\" purge= \"false\" > <element value= \"plone.restapi.behaviors.IBlocks\" /> </property> </object> Test that the content type you've just enabled Blocks behavior is working, by creating a new object of that type from Volto.","title":"How to manually enable Blocks on a content type"},{"location":"blocks/settings/","text":"Blocks settings # You should make Volto aware of your custom blocks. Since Volto have its own set of default blocks, you should extend them by adding your custom ones in your project configuration object. Configuring a new block # So we add these lines to the src/config.js : import MainSliderViewBlock from '@package/components/Blocks/MainSlider/View' ; import MainSliderEditBlock from '@package/components/Blocks/MainSlider/Edit' ; import sliderSVG from '@plone/volto/icons/slider.svg' ; [...] const customBlocks = { mainslider : { id : 'mainslider' , // The name (id) of the block title : 'Main Slider' , // The display name of the block icon : sliderSVG , // The icon used in the block chooser group : 'common' , // The group (blocks can be grouped, displayed in the chooser) view : MainSliderViewBlock , // The view mode component edit : MainSliderEditBlock , // The edit mode component restricted : false , // If the block is restricted, it won't show in the chooser mostUsed : true , // A meta group `most used`, appearing at the top of the chooser blockHasOwnFocusManagement : false , // Set this to true if the block manages its own focus sidebarTab : 0 , // The sidebar tab you want to be selected when selecting the block security : { addPermission : [], // Future proof (not implemented yet) add user permission role(s) view : [], // Future proof (not implemented yet) view user role(s) }, blockHasValue : ( data ) => { // Returns true if the provided block data represents a value for the current block. // Required for alternate default block types implementations. // See also [Settings reference](/configuration/settings-reference) }, }, }; export const blocks = { ... defaultBlocks , blocksConfig : { ... defaultBlocks . blocksConfig , ... customBlocks }, }; We start by importing both view and edit components of our recently created custom block. Note Notice the @package alias. You can use it when importing modules/components from your own project. Then you define the block, using the object described in the example. We also add this piece of code in order to define i18n literals for our new block: import { defineMessages } from 'react-intl' ; ... defineMessages ({ mainslider : { id : 'Main Slider' , defaultMessage : 'Main Slider' , }, }); Our new block should be ready to use in the editor. Other block options # The configuration object also exposes these options requiredBlocks - The required (mandatory, cannot be removed) blocks # This option is used to make the tiles not removable. By default, the Title block is not removable (you won't be able to delete it as the remove handler is not present). groupBlocksOrder - The blocks chooser group order # This option is used to define the order of the groups in the blocks chooser. By default: const groupBlocksOrder = [ { id : 'mostUsed' , title : 'Most used' }, { id : 'text' , title : 'Text' }, { id : 'media' , title : 'Media' }, { id : 'common' , title : 'Common' }, ]; You can change it (and add your own group) in your project configuration object. initialBlocks - Initial Blocks per content type # By default, the default blocks for all content types are a title block and a text block. You can override this and provide your own by modifying the configuration object: const initialBlocks = {}; and provide your own per content type, e.g: const initialBlocks = { Document : [ 'leadimage' , 'title' , 'text' , 'listing' ] };","title":"Settings"},{"location":"blocks/settings/#blocks-settings","text":"You should make Volto aware of your custom blocks. Since Volto have its own set of default blocks, you should extend them by adding your custom ones in your project configuration object.","title":"Blocks settings"},{"location":"blocks/settings/#configuring-a-new-block","text":"So we add these lines to the src/config.js : import MainSliderViewBlock from '@package/components/Blocks/MainSlider/View' ; import MainSliderEditBlock from '@package/components/Blocks/MainSlider/Edit' ; import sliderSVG from '@plone/volto/icons/slider.svg' ; [...] const customBlocks = { mainslider : { id : 'mainslider' , // The name (id) of the block title : 'Main Slider' , // The display name of the block icon : sliderSVG , // The icon used in the block chooser group : 'common' , // The group (blocks can be grouped, displayed in the chooser) view : MainSliderViewBlock , // The view mode component edit : MainSliderEditBlock , // The edit mode component restricted : false , // If the block is restricted, it won't show in the chooser mostUsed : true , // A meta group `most used`, appearing at the top of the chooser blockHasOwnFocusManagement : false , // Set this to true if the block manages its own focus sidebarTab : 0 , // The sidebar tab you want to be selected when selecting the block security : { addPermission : [], // Future proof (not implemented yet) add user permission role(s) view : [], // Future proof (not implemented yet) view user role(s) }, blockHasValue : ( data ) => { // Returns true if the provided block data represents a value for the current block. // Required for alternate default block types implementations. // See also [Settings reference](/configuration/settings-reference) }, }, }; export const blocks = { ... defaultBlocks , blocksConfig : { ... defaultBlocks . blocksConfig , ... customBlocks }, }; We start by importing both view and edit components of our recently created custom block. Note Notice the @package alias. You can use it when importing modules/components from your own project. Then you define the block, using the object described in the example. We also add this piece of code in order to define i18n literals for our new block: import { defineMessages } from 'react-intl' ; ... defineMessages ({ mainslider : { id : 'Main Slider' , defaultMessage : 'Main Slider' , }, }); Our new block should be ready to use in the editor.","title":"Configuring a new block"},{"location":"blocks/settings/#other-block-options","text":"The configuration object also exposes these options","title":"Other block options"},{"location":"blocks/settings/#requiredblocks-the-required-mandatory-cannot-be-removed-blocks","text":"This option is used to make the tiles not removable. By default, the Title block is not removable (you won't be able to delete it as the remove handler is not present).","title":"requiredBlocks - The required (mandatory, cannot be removed) blocks"},{"location":"blocks/settings/#groupblocksorder-the-blocks-chooser-group-order","text":"This option is used to define the order of the groups in the blocks chooser. By default: const groupBlocksOrder = [ { id : 'mostUsed' , title : 'Most used' }, { id : 'text' , title : 'Text' }, { id : 'media' , title : 'Media' }, { id : 'common' , title : 'Common' }, ]; You can change it (and add your own group) in your project configuration object.","title":"groupBlocksOrder - The blocks chooser group order"},{"location":"blocks/settings/#initialblocks-initial-blocks-per-content-type","text":"By default, the default blocks for all content types are a title block and a text block. You can override this and provide your own by modifying the configuration object: const initialBlocks = {}; and provide your own per content type, e.g: const initialBlocks = { Document : [ 'leadimage' , 'title' , 'text' , 'listing' ] };","title":"initialBlocks - Initial Blocks per content type"},{"location":"configuration/environmentvariables/","text":"Environment variables # All the environment variables defined at runtime that have the \"RAZZLE_\" prefix, are available in the browser under window.env ex: If we start the application with an env variable RAZZLE_MY_VARIABLE=some_value build/server.js In the frontend we can access this variable with: window.env.RAZZLE_MY_VARIABLE","title":"Environment variables"},{"location":"configuration/environmentvariables/#environment-variables","text":"All the environment variables defined at runtime that have the \"RAZZLE_\" prefix, are available in the browser under window.env ex: If we start the application with an env variable RAZZLE_MY_VARIABLE=some_value build/server.js In the frontend we can access this variable with: window.env.RAZZLE_MY_VARIABLE","title":"Environment variables"},{"location":"configuration/how-to/","text":"The configuration object # Volto has a central configuration object used to parameterize Volto. It lives in Volto itself but it can be customized in a per project basis. You can find it in Volto in the src/config module. When you create your project via create-volto-app you can find it in src/config.js . import { settings as defaultSettings , views as defaultViews , widgets as defaultWidgets , blocks as defaultBlocks , addonReducers as defaultAddonReducers , } from '@plone/volto/config' ; export const settings = { ... defaultSettings , }; export const views = { ... defaultViews , }; export const widgets = { ... defaultWidgets , }; export const blocks = { ... defaultBlocks , }; export const addonRoutes = []; export const addonReducers = { ... defaultAddonReducers , } It gets the default config from Volto and leave it available to you to customize it in your project. Reading the source code for the ~/config registry is an absolute key in understanding Volto and what can be configured. As you can see from the snipet above, in your Volto project you'll have a src/config.js file. This file is referenced throughout the codebase as ~/config . You can see that, in its default version, all it does is import Volto's default configuration objects and export them further. By reading Volto's src/config/index.js , you'll get to see that Volto provides some default configuration objects ( blocks , widgets , settings , etc), passes them through the applyAddonConfiguration() function, which allows any installed addons to modify this configuration, then spreads and exports its configuration objects. This allows Volto to work the same way in either standalone version (when developing Volto itself), but also when used as a library, referenced from a Volto project. settings # The settings object of the ~/config is a big registry of miscellaneous settings. See the Settings reference for a bit more details. widgets # The widgets object holds the widget registry, used to decide which widget should be used when rendering forms. Check its definition but also the lookup mechanism to understand how things work. views # The views registry allows configuration of the components that will be used to render the content. There are 4 types of views: layout views, which are used based on the layout field of the incoming content content type views, registered view components per Plone content type the default view, which can render the composite page Volto blocks and the error views, to be used for regular error pages (Forbidden, Not Found, etc). addonReducers # In the addonReducers you can register and potentially override (by name) any registered reducer from Volto or other loaded Volto addons. addonRoutes # The addonRoutes is a list of routes declaration, to be used as child sub-routes for the App component. A route declaration looks like this (an example): { path: '/**/chat', component: Chat, } The addonRoutes have a higher priority compared to the default routes, so you can use them to override the existing routes, as well. See src/routes.js for more details. In its configuration, an addon would push additional routes to this data structure: config.addonRoutes.push({ path: '/**/chat', component: Chat });","title":"What is configurable?"},{"location":"configuration/how-to/#the-configuration-object","text":"Volto has a central configuration object used to parameterize Volto. It lives in Volto itself but it can be customized in a per project basis. You can find it in Volto in the src/config module. When you create your project via create-volto-app you can find it in src/config.js . import { settings as defaultSettings , views as defaultViews , widgets as defaultWidgets , blocks as defaultBlocks , addonReducers as defaultAddonReducers , } from '@plone/volto/config' ; export const settings = { ... defaultSettings , }; export const views = { ... defaultViews , }; export const widgets = { ... defaultWidgets , }; export const blocks = { ... defaultBlocks , }; export const addonRoutes = []; export const addonReducers = { ... defaultAddonReducers , } It gets the default config from Volto and leave it available to you to customize it in your project. Reading the source code for the ~/config registry is an absolute key in understanding Volto and what can be configured. As you can see from the snipet above, in your Volto project you'll have a src/config.js file. This file is referenced throughout the codebase as ~/config . You can see that, in its default version, all it does is import Volto's default configuration objects and export them further. By reading Volto's src/config/index.js , you'll get to see that Volto provides some default configuration objects ( blocks , widgets , settings , etc), passes them through the applyAddonConfiguration() function, which allows any installed addons to modify this configuration, then spreads and exports its configuration objects. This allows Volto to work the same way in either standalone version (when developing Volto itself), but also when used as a library, referenced from a Volto project.","title":"The configuration object"},{"location":"configuration/how-to/#settings","text":"The settings object of the ~/config is a big registry of miscellaneous settings. See the Settings reference for a bit more details.","title":"settings"},{"location":"configuration/how-to/#widgets","text":"The widgets object holds the widget registry, used to decide which widget should be used when rendering forms. Check its definition but also the lookup mechanism to understand how things work.","title":"widgets"},{"location":"configuration/how-to/#views","text":"The views registry allows configuration of the components that will be used to render the content. There are 4 types of views: layout views, which are used based on the layout field of the incoming content content type views, registered view components per Plone content type the default view, which can render the composite page Volto blocks and the error views, to be used for regular error pages (Forbidden, Not Found, etc).","title":"views"},{"location":"configuration/how-to/#addonreducers","text":"In the addonReducers you can register and potentially override (by name) any registered reducer from Volto or other loaded Volto addons.","title":"addonReducers"},{"location":"configuration/how-to/#addonroutes","text":"The addonRoutes is a list of routes declaration, to be used as child sub-routes for the App component. A route declaration looks like this (an example): { path: '/**/chat', component: Chat, } The addonRoutes have a higher priority compared to the default routes, so you can use them to override the existing routes, as well. See src/routes.js for more details. In its configuration, an addon would push additional routes to this data structure: config.addonRoutes.push({ path: '/**/chat', component: Chat });","title":"addonRoutes"},{"location":"configuration/internalproxy/","text":"Internal proxy to API # While in development, Volto has an internal proxy to the backend API enabled by default. It provides a better developer experience out of the box, so the developer doesn't has to deal with CORS and can focus in develop/test drive/demo Volto. Configuration # By default, Volto expects a Plone backend located at http://localhost:8080/Plone . These are the settings that allows you to configure the API and how the proxy works: apiPath [API_PATH] - URL of the backend, used through Volto. By default, the proxy URL. devProxyToApiPath - The real backend URL, used by the proxy. By default, http://localhost:8080/Plone Tip You don't want to deal with CORS in your production deployments, so the proxy is only enabled in development mode (e.g yarn start ) Note You can disable the proxy by redefining a new apiPath and redefining an empty devProxyToApiPath setting. Here are some examples. Redefining the proxy target # export const settings = { ... defaultSettings , devProxyToApiPath : 'http://localhost:8081/mysite' , }; Disabling the proxy # export const settings = { ... defaultSettings , apiPath : process . env . RAZZLE_API_PATH || `http://localhost:8081/mysite` , // for Plone devProxyToApiPath : '' , // Set it to '' for disabling the proxy }; or use the environment variable: RAZZLE_API_PATH = http://localhost:8081/mysite yarn start","title":"Internal proxy"},{"location":"configuration/internalproxy/#internal-proxy-to-api","text":"While in development, Volto has an internal proxy to the backend API enabled by default. It provides a better developer experience out of the box, so the developer doesn't has to deal with CORS and can focus in develop/test drive/demo Volto.","title":"Internal proxy to API"},{"location":"configuration/internalproxy/#configuration","text":"By default, Volto expects a Plone backend located at http://localhost:8080/Plone . These are the settings that allows you to configure the API and how the proxy works: apiPath [API_PATH] - URL of the backend, used through Volto. By default, the proxy URL. devProxyToApiPath - The real backend URL, used by the proxy. By default, http://localhost:8080/Plone Tip You don't want to deal with CORS in your production deployments, so the proxy is only enabled in development mode (e.g yarn start ) Note You can disable the proxy by redefining a new apiPath and redefining an empty devProxyToApiPath setting. Here are some examples.","title":"Configuration"},{"location":"configuration/internalproxy/#redefining-the-proxy-target","text":"export const settings = { ... defaultSettings , devProxyToApiPath : 'http://localhost:8081/mysite' , };","title":"Redefining the proxy target"},{"location":"configuration/internalproxy/#disabling-the-proxy","text":"export const settings = { ... defaultSettings , apiPath : process . env . RAZZLE_API_PATH || `http://localhost:8081/mysite` , // for Plone devProxyToApiPath : '' , // Set it to '' for disabling the proxy }; or use the environment variable: RAZZLE_API_PATH = http://localhost:8081/mysite yarn start","title":"Disabling the proxy"},{"location":"configuration/multilingual/","text":"Multilingual # Volto provide support for Plone's Multilingual feature. You need to install Multiligual support in Plone (plone.app.multilingual add-on), that comes available by default since Plone 5. Volto configuration # You need to enable multilingual in Volto's configuration object: export const settings = { ... defaultSettings , isMultilingual : true , supportedLanguages : [ 'en' , 'de' , 'ca' ], defaultLanguage : 'en' } Declare the language you want to support in your site in the supportedLanguages array, and which is the default language of your site. Warning The default language and the supported languages must match the one set in the Plone side, and those should be set using GenericSetup using your policy package, or manually via the Languages control panel. Features # Volto Multilingual features include: Language detector that detects the language preference (cookie) and redirects to the related language root folder Language switcher that allows user to switch between languages Add menu entries that allows to create and link a new content with the original one in one of the supported languages set in the site When users use the language switcher to change language from a translated content, they are redirected to the linked content (within the same translation group) To be done: Manual link two objects Manual deletion of a link (unlink) between two objects","title":"Multilingual"},{"location":"configuration/multilingual/#multilingual","text":"Volto provide support for Plone's Multilingual feature. You need to install Multiligual support in Plone (plone.app.multilingual add-on), that comes available by default since Plone 5.","title":"Multilingual"},{"location":"configuration/multilingual/#volto-configuration","text":"You need to enable multilingual in Volto's configuration object: export const settings = { ... defaultSettings , isMultilingual : true , supportedLanguages : [ 'en' , 'de' , 'ca' ], defaultLanguage : 'en' } Declare the language you want to support in your site in the supportedLanguages array, and which is the default language of your site. Warning The default language and the supported languages must match the one set in the Plone side, and those should be set using GenericSetup using your policy package, or manually via the Languages control panel.","title":"Volto configuration"},{"location":"configuration/multilingual/#features","text":"Volto Multilingual features include: Language detector that detects the language preference (cookie) and redirects to the related language root folder Language switcher that allows user to switch between languages Add menu entries that allows to create and link a new content with the original one in one of the supported languages set in the site When users use the language switcher to change language from a translated content, they are redirected to the linked content (within the same translation group) To be done: Manual link two objects Manual deletion of a link (unlink) between two objects","title":"Features"},{"location":"configuration/richeditor-settings/","text":"RichEditor Settings # You can customize how the Rich Text Editor behaves and its features. These are controlled from the config.js settings. Adding an underline button feature # In this chapter we will learn how to change settings for the Rich Text Editor. We will add a button to the toolbar to underline the selected text. In the config.js file we will create a new button. import React from 'react' ; import createInlineStyleButton from 'draft-js-buttons/lib/utils/createInlineStyleButton' ; import Icon from '@plone/volto/components/theme/Icon/Icon' ; import underlineSVG from '@plone/volto/icons/underline.svg' ; const UnderlineButton = createInlineStyleButton ({ style : 'UNDERLINE' , children : < Icon name = { underlineSVG } size = \"24px\" />, }); Next we will add the button to the toolbar. export const settings = { ... defaultSettings , richTextEditorInlineToolbarButtons : [ UnderlineButton , ... defaultSettings . richTextEditorInlineToolbarButtons , ], }; Add a code button feature # Add a button to the toolbar to style a text selection as CODE . /** * Add your config changes here. * @module config * @example * export const settings = { * ...defaultSettings, * port: 4300, * listBlockTypes: { * ...defaultSettings.listBlockTypes, * 'my-list-item', * } * } */ import React from 'react' ; import createInlineStyleButton from 'draft-js-buttons/lib/utils/createInlineStyleButton' ; import Icon from '@plone/volto/components/theme/Icon/Icon' ; import underlineSVG from '@plone/volto/icons/underline.svg' ; import codeSVG from '@plone/volto/icons/code.svg' ; import { settings as defaultSettings , views as defaultViews , widgets as defaultWidgets , blocks as defaultBlocks , } from '@plone/volto/config' ; import { AlbumView , FullView , RatingWidget } from './components' ; const UnderlineButton = createInlineStyleButton ({ style : 'UNDERLINE' , children : < Icon name = { underlineSVG } size = \"24px\" />, }); const CodeButton = createInlineStyleButton ({ style : 'CODE' , children : < Icon name = { codeSVG } size = \"24px\" />, }); export const settings = { ... defaultSettings , richTextEditorInlineToolbarButtons : [ CodeButton , UnderlineButton , ... defaultSettings . richTextEditorInlineToolbarButtons , ], }; export const views = { ... defaultViews , layoutViews : { ... defaultViews . layoutViews , album_view : AlbumView , full_view : FullView , }, }; export const widgets = { ... defaultWidgets , id : { ... defaultWidgets . id , rating : RatingWidget , }, }; export const blocks = { ... defaultBlocks , };","title":"Richeditor settings"},{"location":"configuration/richeditor-settings/#richeditor-settings","text":"You can customize how the Rich Text Editor behaves and its features. These are controlled from the config.js settings.","title":"RichEditor Settings"},{"location":"configuration/richeditor-settings/#adding-an-underline-button-feature","text":"In this chapter we will learn how to change settings for the Rich Text Editor. We will add a button to the toolbar to underline the selected text. In the config.js file we will create a new button. import React from 'react' ; import createInlineStyleButton from 'draft-js-buttons/lib/utils/createInlineStyleButton' ; import Icon from '@plone/volto/components/theme/Icon/Icon' ; import underlineSVG from '@plone/volto/icons/underline.svg' ; const UnderlineButton = createInlineStyleButton ({ style : 'UNDERLINE' , children : < Icon name = { underlineSVG } size = \"24px\" />, }); Next we will add the button to the toolbar. export const settings = { ... defaultSettings , richTextEditorInlineToolbarButtons : [ UnderlineButton , ... defaultSettings . richTextEditorInlineToolbarButtons , ], };","title":"Adding an underline button feature"},{"location":"configuration/richeditor-settings/#add-a-code-button-feature","text":"Add a button to the toolbar to style a text selection as CODE . /** * Add your config changes here. * @module config * @example * export const settings = { * ...defaultSettings, * port: 4300, * listBlockTypes: { * ...defaultSettings.listBlockTypes, * 'my-list-item', * } * } */ import React from 'react' ; import createInlineStyleButton from 'draft-js-buttons/lib/utils/createInlineStyleButton' ; import Icon from '@plone/volto/components/theme/Icon/Icon' ; import underlineSVG from '@plone/volto/icons/underline.svg' ; import codeSVG from '@plone/volto/icons/code.svg' ; import { settings as defaultSettings , views as defaultViews , widgets as defaultWidgets , blocks as defaultBlocks , } from '@plone/volto/config' ; import { AlbumView , FullView , RatingWidget } from './components' ; const UnderlineButton = createInlineStyleButton ({ style : 'UNDERLINE' , children : < Icon name = { underlineSVG } size = \"24px\" />, }); const CodeButton = createInlineStyleButton ({ style : 'CODE' , children : < Icon name = { codeSVG } size = \"24px\" />, }); export const settings = { ... defaultSettings , richTextEditorInlineToolbarButtons : [ CodeButton , UnderlineButton , ... defaultSettings . richTextEditorInlineToolbarButtons , ], }; export const views = { ... defaultViews , layoutViews : { ... defaultViews . layoutViews , album_view : AlbumView , full_view : FullView , }, }; export const widgets = { ... defaultWidgets , id : { ... defaultWidgets . id , rating : RatingWidget , }, }; export const blocks = { ... defaultBlocks , };","title":"Add a code button feature"},{"location":"configuration/settings-reference/","text":"Settings reference guide # This is a summary of all the configuration options and what they control. Note This list is still incomplete, contributions are welcomed! navDepth # Navigation levels depth used in the navigation endpoint calls. Increasing this is useful for implementing fat navigation menus. Defaults to 1 . defaultBlockType # The default block type in Volto is \"text\", which uses the current DraftJS-based implementation for the rich text editor. Future alternative rich text editors will need to use this setting and replace it with their block type. The block definition should also include the blockHasValue function, which is needed to activate the Block Chooser functionality. See this function signature in Blocks > Settings . sentryOptions # Sentry configuration: import { settings as defaultSettings , } from '@plone/volto/config' ; const settings = { ... defaultSettings , sentryOptions : { ... defaultSettings . sentryOptions , dsn : 'https://key@sentry.io/1' , environment : 'production' , release : '1.2.3' , serverName : 'volto' , tags : { site : 'foo.bar' , app : 'test_app' , logger : 'volto' , }, extras : { key : 'value' , }, integrations : [ ... defaultSettings . sentryOptions . integrations , // new MyAwesomeIntegration() ] } }; See more about Sentry integration . contentIcons # With this property you can configure Content Types icons. Those are visible in Contents view (ex \"Folder contents\"). The default ones are in config/ContentIcons.jsx and you can extend them in your project's config for custom content types using settings.contentIcons . In Volto projects, you can configure this for custom content types like: import * as config from '@plone/volto/config' ; import courseSVG from './icons/course.svg' ; export const settings = { ... config . settings , contentIcons : { ... config . settings . contentIcons , Course : courseSVG , };","title":"Settings reference guide"},{"location":"configuration/settings-reference/#settings-reference-guide","text":"This is a summary of all the configuration options and what they control. Note This list is still incomplete, contributions are welcomed!","title":"Settings reference guide"},{"location":"configuration/settings-reference/#navdepth","text":"Navigation levels depth used in the navigation endpoint calls. Increasing this is useful for implementing fat navigation menus. Defaults to 1 .","title":"navDepth"},{"location":"configuration/settings-reference/#defaultblocktype","text":"The default block type in Volto is \"text\", which uses the current DraftJS-based implementation for the rich text editor. Future alternative rich text editors will need to use this setting and replace it with their block type. The block definition should also include the blockHasValue function, which is needed to activate the Block Chooser functionality. See this function signature in Blocks > Settings .","title":"defaultBlockType"},{"location":"configuration/settings-reference/#sentryoptions","text":"Sentry configuration: import { settings as defaultSettings , } from '@plone/volto/config' ; const settings = { ... defaultSettings , sentryOptions : { ... defaultSettings . sentryOptions , dsn : 'https://key@sentry.io/1' , environment : 'production' , release : '1.2.3' , serverName : 'volto' , tags : { site : 'foo.bar' , app : 'test_app' , logger : 'volto' , }, extras : { key : 'value' , }, integrations : [ ... defaultSettings . sentryOptions . integrations , // new MyAwesomeIntegration() ] } }; See more about Sentry integration .","title":"sentryOptions"},{"location":"configuration/settings-reference/#contenticons","text":"With this property you can configure Content Types icons. Those are visible in Contents view (ex \"Folder contents\"). The default ones are in config/ContentIcons.jsx and you can extend them in your project's config for custom content types using settings.contentIcons . In Volto projects, you can configure this for custom content types like: import * as config from '@plone/volto/config' ; import courseSVG from './icons/course.svg' ; export const settings = { ... config . settings , contentIcons : { ... config . settings . contentIcons , Course : courseSVG , };","title":"contentIcons"},{"location":"contributing/","text":"Basic design principles # Since the very beginning, Volto has been developed with a set of principles in mind, brought from the years of experience developing Plone core and implementing projects on it. Approachability Developer experience first Volto UI/UX is Pastanaga UI Do not overengineer things Each feature has only one way of doing it Frontend and backend are meant to be decoupled Focus on the UI/UX implementation and upcoming challenges Following you can find the reasoning behind these principles. Approachability # Volto has to be 100% approachable by someone with zero Plone or Python knowledge. This is the main Volto principle. That means this someone has to be able to run, test and use Volto (and thus Plone), and ultimatelly customize a simple project without any problem and without having to touch Plone by any means or write a single line of Python nor implement a single Plone add-on product. This person has to be able of using only JavaScript to parameterize it. The rationale behind this is to be able to attract people from the React community or other communities and drag them to use and know Plone using Volto as a facilitator. This way we keep the existing learning curve coming from Plone away from Volto, so Volto can make (and control) from scratch its own learning curve, without any inherited burden. A number of decisions have been made based on this directive. To give an example, that's why it was decided not to use the tiles implementation and definitions existing in the Plone ecosystem. We started to do it, but all of a sudden it felt like duplicating efforts by defining them on both sides, while clearly, having them defined on Plone didn't give any value. Developer experience first # Developing in Volto has to be fun, not a burden. Implementing or customizing anything in Volto (or in a Volto project) should be easy and straightforward, and done in a single, simple way. Developing for Plone has become a burden, even doing the most simple thing often implies teaching several other things and technologies, and explain the reasoning (and the history!) behind why it is like that, and worse, often say sorry about it. Those who teach Plone out there know it's like this. Almost twenty years of history, thousands of different developers, improvements, deprecations, introduction of new technologies, and removal of them in such a big and old project is normal it's like it is, nobody is to take the blame on it. In Volto we have a blank page in front of us. Let's work to keep it clean and shiny. Volto UI/UX is Pastanaga UI # Volto has its own UI/UX design, it's Pastanaga UI. It was conceived from scratch to match nowadays trends and to give fresh air what a content management system user experience should be. Do not overengineer things # In the Plone community we had a tendency to overengineer things. We have the chance to stop doing it. While developing Volto we live in the Web Technologies world, let's use them in a simple and straightforward way. Do not try to implement ZCA, Portlets or five way adapters for widgets in JS. Each feature has only one way of doing it # We won't introduce (at least willingly) several ways of doing the same thing. Then you have to document them both, and explain to the user which is the best. Especially in cases where you do something in the backend or in the frontend. Frontend and backend are meant to be decoupled # So let's them keep them decoupled. In the future, while developing Volto and in our Volto projects, we will face a lot of decisions and answer questions like: What is the value to define something in the backend? Is that going to improve the (frontend) developer experience? Is separating this going to do any good or will it force us to repeat ourselves? or worse, it would take two people (frontend dev and a backend dev) to accomplish a simple task? Are we introducing two different ways of doing things? Focus on the UI/UX implementation and upcoming challenges # Volto is a frontend UI implementation of a CMS backend. We need to focus on this instead of focusing on the relationship with the backend(s). JS world advances quick, and we have to keep pace with it. React's own async (Suspense) mode it's on its way, and that will change enough things in React world and we have to keep up with these changes.","title":"Basic design principles"},{"location":"contributing/#basic-design-principles","text":"Since the very beginning, Volto has been developed with a set of principles in mind, brought from the years of experience developing Plone core and implementing projects on it. Approachability Developer experience first Volto UI/UX is Pastanaga UI Do not overengineer things Each feature has only one way of doing it Frontend and backend are meant to be decoupled Focus on the UI/UX implementation and upcoming challenges Following you can find the reasoning behind these principles.","title":"Basic design principles"},{"location":"contributing/#approachability","text":"Volto has to be 100% approachable by someone with zero Plone or Python knowledge. This is the main Volto principle. That means this someone has to be able to run, test and use Volto (and thus Plone), and ultimatelly customize a simple project without any problem and without having to touch Plone by any means or write a single line of Python nor implement a single Plone add-on product. This person has to be able of using only JavaScript to parameterize it. The rationale behind this is to be able to attract people from the React community or other communities and drag them to use and know Plone using Volto as a facilitator. This way we keep the existing learning curve coming from Plone away from Volto, so Volto can make (and control) from scratch its own learning curve, without any inherited burden. A number of decisions have been made based on this directive. To give an example, that's why it was decided not to use the tiles implementation and definitions existing in the Plone ecosystem. We started to do it, but all of a sudden it felt like duplicating efforts by defining them on both sides, while clearly, having them defined on Plone didn't give any value.","title":"Approachability"},{"location":"contributing/#developer-experience-first","text":"Developing in Volto has to be fun, not a burden. Implementing or customizing anything in Volto (or in a Volto project) should be easy and straightforward, and done in a single, simple way. Developing for Plone has become a burden, even doing the most simple thing often implies teaching several other things and technologies, and explain the reasoning (and the history!) behind why it is like that, and worse, often say sorry about it. Those who teach Plone out there know it's like this. Almost twenty years of history, thousands of different developers, improvements, deprecations, introduction of new technologies, and removal of them in such a big and old project is normal it's like it is, nobody is to take the blame on it. In Volto we have a blank page in front of us. Let's work to keep it clean and shiny.","title":"Developer experience first"},{"location":"contributing/#volto-uiux-is-pastanaga-ui","text":"Volto has its own UI/UX design, it's Pastanaga UI. It was conceived from scratch to match nowadays trends and to give fresh air what a content management system user experience should be.","title":"Volto UI/UX is Pastanaga UI"},{"location":"contributing/#do-not-overengineer-things","text":"In the Plone community we had a tendency to overengineer things. We have the chance to stop doing it. While developing Volto we live in the Web Technologies world, let's use them in a simple and straightforward way. Do not try to implement ZCA, Portlets or five way adapters for widgets in JS.","title":"Do not overengineer things"},{"location":"contributing/#each-feature-has-only-one-way-of-doing-it","text":"We won't introduce (at least willingly) several ways of doing the same thing. Then you have to document them both, and explain to the user which is the best. Especially in cases where you do something in the backend or in the frontend.","title":"Each feature has only one way of doing it"},{"location":"contributing/#frontend-and-backend-are-meant-to-be-decoupled","text":"So let's them keep them decoupled. In the future, while developing Volto and in our Volto projects, we will face a lot of decisions and answer questions like: What is the value to define something in the backend? Is that going to improve the (frontend) developer experience? Is separating this going to do any good or will it force us to repeat ourselves? or worse, it would take two people (frontend dev and a backend dev) to accomplish a simple task? Are we introducing two different ways of doing things?","title":"Frontend and backend are meant to be decoupled"},{"location":"contributing/#focus-on-the-uiux-implementation-and-upcoming-challenges","text":"Volto is a frontend UI implementation of a CMS backend. We need to focus on this instead of focusing on the relationship with the backend(s). JS world advances quick, and we have to keep pace with it. React's own async (Suspense) mode it's on its way, and that will change enough things in React world and we have to keep up with these changes.","title":"Focus on the UI/UX implementation and upcoming challenges"},{"location":"contributing/guidelines/","text":"Guidelines # You probably came here by clicking one of the \u2018guidelines for contributing\u2019 links on GitHub. You probably have an issue to report or you want to create a pull request. Thanks a lot! Let\u2019s bring you up to speed with the minimum you need to know to start contributing. Create an issue # If you know the issue is for a specific package, you can add an issue there. When in doubt, create one in the CMFPlone issue tracker. Please specify a few things: What steps reproduce the problem? What do you expect when you do that? What happens instead? Which Plone version are you using? If it is a visual issue, can you add a screenshot? Create a pull request # Legally, you can NOT contribute code unless you have signed the contributor agreement. This means that we can NOT accept pull requests from you unless this is done, so please don\u2019t put the code reviewers at risk and do it anyways. For new features, an addition to documentation is probably needed. If the feature includes a breaking change, you should also add the breaking and how to upgrade in the upgrade guide . All text that can be shown in a browser must be translatable. Please mark all such strings as translatable as defined in the i18n guide Code formatting and linting are already enforced in Volto. See if you can use git to squash multiple commits into one where this makes sense. If you are not comfortable with git, never mind. If after reading this you become hesitant: don\u2019t worry. You can always create a pull request, mark it as WIP (work in progress), and improve the above points later.","title":"Guidelines"},{"location":"contributing/guidelines/#guidelines","text":"You probably came here by clicking one of the \u2018guidelines for contributing\u2019 links on GitHub. You probably have an issue to report or you want to create a pull request. Thanks a lot! Let\u2019s bring you up to speed with the minimum you need to know to start contributing.","title":"Guidelines"},{"location":"contributing/guidelines/#create-an-issue","text":"If you know the issue is for a specific package, you can add an issue there. When in doubt, create one in the CMFPlone issue tracker. Please specify a few things: What steps reproduce the problem? What do you expect when you do that? What happens instead? Which Plone version are you using? If it is a visual issue, can you add a screenshot?","title":"Create an issue"},{"location":"contributing/guidelines/#create-a-pull-request","text":"Legally, you can NOT contribute code unless you have signed the contributor agreement. This means that we can NOT accept pull requests from you unless this is done, so please don\u2019t put the code reviewers at risk and do it anyways. For new features, an addition to documentation is probably needed. If the feature includes a breaking change, you should also add the breaking and how to upgrade in the upgrade guide . All text that can be shown in a browser must be translatable. Please mark all such strings as translatable as defined in the i18n guide Code formatting and linting are already enforced in Volto. See if you can use git to squash multiple commits into one where this makes sense. If you are not comfortable with git, never mind. If after reading this you become hesitant: don\u2019t worry. You can always create a pull request, mark it as WIP (work in progress), and improve the above points later.","title":"Create a pull request"},{"location":"contributing/volips/","text":"","title":"Volips"},{"location":"deploying/apache/","text":"Apache # Apache configuration for a Plone backend deployed under /api and a Volto frontend deployed under the root \"/\". This configuration also redirects http -> https: <Proxy balancer://plonebackend > ProxySet lbmethod=bybusyness BalancerMember http://127.0.0.1:8001 </Proxy> <Proxy balancer://voltofrontend > # Use Pending Request Counting Algorithm (s. http://httpd.apache.org/docs/current/mod/mod_lbmethod_bybusyness.html). # This will reduce latencies that occur as a result of long running requests temporarily blocking a ZEO client. # You will need to install the separate mod_lbmethod_bybusyness module in Apache 2.4. ProxySet lbmethod=bybusyness BalancerMember http://127.0.0.1:8010 </Proxy> RewriteEngine On ProxyPreserveHost On RewriteCond %{ENV:HTTP_VHOST} ^example\\.com$ [NC] RewriteRule (.*) https://www.example.com$1 [R,L] RewriteCond %{ENV:HTTP_VHOST} ^www\\.example\\.com$ [NC] RewriteRule ^/api($|/.*) balancer://plonebackend/VirtualHostBase/https/www.example.com:443/Plone/VirtualHostRoot/_vh_api$1 [P,L] RewriteCond %{ENV:HTTP_VHOST} ^www\\.example\\.com$ [NC] RewriteRule ^(.*) balancer://voltofrontend$1 [P,L] ProxyPassReverse / balancer://voltofrontend/","title":"Using apache"},{"location":"deploying/apache/#apache","text":"Apache configuration for a Plone backend deployed under /api and a Volto frontend deployed under the root \"/\". This configuration also redirects http -> https: <Proxy balancer://plonebackend > ProxySet lbmethod=bybusyness BalancerMember http://127.0.0.1:8001 </Proxy> <Proxy balancer://voltofrontend > # Use Pending Request Counting Algorithm (s. http://httpd.apache.org/docs/current/mod/mod_lbmethod_bybusyness.html). # This will reduce latencies that occur as a result of long running requests temporarily blocking a ZEO client. # You will need to install the separate mod_lbmethod_bybusyness module in Apache 2.4. ProxySet lbmethod=bybusyness BalancerMember http://127.0.0.1:8010 </Proxy> RewriteEngine On ProxyPreserveHost On RewriteCond %{ENV:HTTP_VHOST} ^example\\.com$ [NC] RewriteRule (.*) https://www.example.com$1 [R,L] RewriteCond %{ENV:HTTP_VHOST} ^www\\.example\\.com$ [NC] RewriteRule ^/api($|/.*) balancer://plonebackend/VirtualHostBase/https/www.example.com:443/Plone/VirtualHostRoot/_vh_api$1 [P,L] RewriteCond %{ENV:HTTP_VHOST} ^www\\.example\\.com$ [NC] RewriteRule ^(.*) balancer://voltofrontend$1 [P,L] ProxyPassReverse / balancer://voltofrontend/","title":"Apache"},{"location":"deploying/pm2/","text":"Deployment using a node process manager (pm2) # PM2 is a popular and maintained process manager based in node ( https://pm2.keymetrics.io/ ) Info You can use the good'ol known supervisord as well. However, the supervisord project is stalled and in low maintenance mode last years. PM2 is a good alternative, and as you'll see you can manage all kind of processes, not only node ones, including the Plone processes. Create a file mywebsite.com.pm2.config.js in your repo or on your server. Important Make sure your pm2 config file sufix ends in config.js , otherwise PM2 will ignore it. module . exports = { apps : [ { script : \"/srv/mywebsite.com/build/server.js\" , name : \"mywebsite.com-volto\" , cwd : \"/srv/mywebsite.com\" }, { script : \"/srv/mywebsite.com/api/bin/zeo\" , args : \"fg\" , name : \"mywebsite.com-api-zeo\" , cwd : \"/srv/mywebsite.com\" , interpreter : \"/srv/mywebsite.com/api/bin/python\" }, { script : \"/srv/mywebsite.com/api/bin/instance1\" , args : \"console\" , name : \"mywebsite.com-api-instance1\" , cwd : \"/srv/mywebsite.com\" , interpreter : \"/srv/mywebsite.com/api/bin/python\" }, { script : \"/srv/mywebsite.com/api/bin/instance2\" , args : \"console\" , name : \"mywebsite.com-api-instance2\" , cwd : \"/srv/mywebsite.com\" , interpreter : \"/srv/mywebsite.com/api/bin/python\" } ] }; \"mywebsite.com-volto\" starts the Node process that is responsible for Volto server-side-rendering. \"mywebsite.com-api-zeo\" starts the ZEO server \"mywebsite.com-api-instance1\" starts the first Zope instance \"mywebsite.com-api-instance2\" starts the second Zope instance Add more Zope instances if necessary.","title":"Using PM2"},{"location":"deploying/pm2/#deployment-using-a-node-process-manager-pm2","text":"PM2 is a popular and maintained process manager based in node ( https://pm2.keymetrics.io/ ) Info You can use the good'ol known supervisord as well. However, the supervisord project is stalled and in low maintenance mode last years. PM2 is a good alternative, and as you'll see you can manage all kind of processes, not only node ones, including the Plone processes. Create a file mywebsite.com.pm2.config.js in your repo or on your server. Important Make sure your pm2 config file sufix ends in config.js , otherwise PM2 will ignore it. module . exports = { apps : [ { script : \"/srv/mywebsite.com/build/server.js\" , name : \"mywebsite.com-volto\" , cwd : \"/srv/mywebsite.com\" }, { script : \"/srv/mywebsite.com/api/bin/zeo\" , args : \"fg\" , name : \"mywebsite.com-api-zeo\" , cwd : \"/srv/mywebsite.com\" , interpreter : \"/srv/mywebsite.com/api/bin/python\" }, { script : \"/srv/mywebsite.com/api/bin/instance1\" , args : \"console\" , name : \"mywebsite.com-api-instance1\" , cwd : \"/srv/mywebsite.com\" , interpreter : \"/srv/mywebsite.com/api/bin/python\" }, { script : \"/srv/mywebsite.com/api/bin/instance2\" , args : \"console\" , name : \"mywebsite.com-api-instance2\" , cwd : \"/srv/mywebsite.com\" , interpreter : \"/srv/mywebsite.com/api/bin/python\" } ] }; \"mywebsite.com-volto\" starts the Node process that is responsible for Volto server-side-rendering. \"mywebsite.com-api-zeo\" starts the ZEO server \"mywebsite.com-api-instance1\" starts the first Zope instance \"mywebsite.com-api-instance2\" starts the second Zope instance Add more Zope instances if necessary.","title":"Deployment using a node process manager (pm2)"},{"location":"deploying/sentry/","text":"Integration with SENTRY # Prerequisities # In Sentry create a new organization, and add a project to it On the projects settings page, from Client Keys (DSN), take the SENTRY_DSN Create an API Token: on the top left corner, click on your name -> API keys and create a new token, \"project:write\" scope should be selected. Note: Instructions tested with Sentry 9.1.2 Setup # Volto creates bundles of the source codes, if an error is sent to sentry, it will only show the traceback in the bundles. To have nice traceback, we have to upload the source code and source map in sentry. This doesn't have to be done manually, we can configure our volto application to do all the steps automatically. There are 2 ways to configure the application: 1. Buildtime # This can be used when the application is deployed directly on a host machine, and built locally. The configuration is done using environment variables: SENTRY_DSN - required to enable the feature SENTRY_URL - the url of sentry SENTRY_AUTH_TOKEN - the authentication token for sentry SENTRY_ORG - the name of the organization in sentry SENTRY_PROJECT -the name of the project in sentry SENTRY_RELEASE - release number SENTRY_FRONTEND_CONFIG - optional, here we can specify TAGS and ADDITIONAL DATA for the messages from the browser we send to sentry SENTRY_BACKEND_CONFIG - same as SENTRY_FRONTEND_CONFIG, but we configure the messages from the backend If these env variables are configured, when the app is built, a new release will be created in sentry, and the source code and source maps will be uploaded it. After starting the application if an error will occure, the errors will be sent to sentry, and will be linked to the specified release. Example of usage: SENTRY_URL = https://mysentry.com SENTRY_AUTH_TOKEN = foo SENTRY_ORG = my_organization SENTRY_PROJECT = new_project SENTRY_RELEASE = 2 .0.0 SENTRY_DSN = https://boo@sentry.com/1 yarn build node build/server.js 2. Runtime # Within your Volto project or a dedicated Volto add-on you can configure Sentry via settings.sentryOptions configuration key: import { settings as defaultSettings , } from '@plone/volto/config' ; const settings = { ... defaultSettings , sentryOptions : { ... defaultSettings . sentryOptions , dsn : 'https://key@sentry.io/1' , environment : 'production' , release : '1.2.3' , serverName : 'volto' , tags : { site : 'foo.bar' , app : 'test_app' , logger : 'volto' , }, extras : { key : 'value' , }, integrations : [ ... defaultSettings . sentryOptions . integrations , // new MyAwesomeIntegration() ] } }; See more about [ Sentry Custom Integrations ]( https : //docs.sentry.io/platforms/javascript/configuration/integrations) In case you plan to use the application using docker , you will not want to have the sentry setup in the docker image . The configuration for setting up sentry on runtime is very similar as how we set it up for buildtime , but with some small differences : - SENTRY_URL - the url of sentry - SENTRY_AUTH_TOKEN - the authentication token for sentry - SENTRY_ORG - the name of the organization in sentry - SENTRY_PROJECT - the name of the project in sentry - SENTRY_RELEASE - release number - RAZZLE_SENTRY_DSN - required to enable the feature - RAZZLE_SENTRY_FRONTEND_CONFIG - optional , here we can specify TAGS and ADDITIONAL DATA for the messages from the browser we send to sentry - RAZZLE_SENTRY_BACKEND_CONFIG - same as RAZZLE_SENTRY_FRONTEND_CONFIG , but we configure the messages from the backend - RAZZLE_SENTRY_RELEASE - release number , should be the same as SENTRY_RELEASE In the entrypoint of our docker image we have to add the . / create - sentry - release . sh script . When the container is started , this script will check in sentry if the specified release already exists , if not , it will create it and upload the source code and the source maps . The script can be executed also manually and if we want to overwrite the existing files in sentry , we can use the -- force flag : ```bash ./create-sentry-release.sh --force Example of entrypoint: #!/usr/bin/env bash set -Ex function apply_path { mainjs = ./build/server.js bundlejs = ./build/public/static/js/*.js test -f $mainjs echo \"Check that we have API_PATH and API vars\" test -n \" $API_PATH \" sed -i \"s#VOLTO_API_PATH# ${ API_PATH } #g\" $mainjs sed -i \"s#VOLTO_API_PATH# ${ API_PATH } #g\" $bundlejs sed -i \"s#VOLTO_INTERNAL_API_PATH# ${ INTERNAL_API_PATH } #g\" $mainjs sed -i \"s#VOLTO_INTERNAL_API_PATH# ${ INTERNAL_API_PATH } #g\" $bundlejs gzip -fk $mainjs } # Should we monkey patch? test -n \" $API_PATH \" && apply_path ./create-sentry-release.sh echo \"Starting Volto\" exec \" $@ \" Starting with docker: docker run -p 3000 :3000 -p 3001 :3001 -e SENTRY_URL = https://mysentry.com -e SENTRY_AUTH_TOKEN = foo -e SENTRY_ORG = my_organization -e SENTRY_PROJECT = new_project -e SENTRY_RELEASE = 2 .0.0 -e RAZZLE_SENTRY_DSN = https://boo@sentry.com/1 -e RAZZLE_SENTRY_RELEASE = 2 .0.0 volto-app:latest Or using docker-compose: version : '3' services : volto : build : volto ports : - 3000:3000 - 3001:3001 environment : - SENTRY_URL=https://mysentry.com - SENTRY_AUTH_TOKEN=foo - SENTRY_ORG=my_organization - SENTRY_PROJECT=new_project - SENTRY_RELEASE=2.0.0 - RAZZLE_SENTRY_DSN=https://boo@sentry.com/1 - RAZZLE_SENTRY_RELEASE=2.0.0 Configuration options # This applies to both SENTRY_FRONTEND_CONFIG and SENTRY_BACKEND_CONFIG Note: In case you are using buildtime configuration you have to use SENTRY_FRONTEND_CONFIG and SENTRY_BACKEND_CONFIG. But if you are using runtime configuration, use RAZZLE_SENTRY_FRONTEND_CONFIG and RAZZLE_SENTRY_BACKEND_CONFIG We have the possibility to add TAGS and ADDITIONAL DATA for our messages for categorization in SENTRY. We can configure these 2 variables separately, as we might want to separate the messages from frontend and backend. Example of configurations: { \"tags\" : { \"site\" : \"www.test.com\" , \"app\" : \"test_app\" }, \"extras\" : { \"logger\" : \"javascript-frontend\" }, \"environment\" : \"development\" , \"serverName\" : \"server #1\" , \"maxBreadcrumbs\" : 50 } Example of usage with buildtime setup: SENTRY_URL = https://mysentry.com SENTRY_AUTH_TOKEN = foo SENTRY_ORG = my_organization SENTRY_PROJECT = new_project SENTRY_RELEASE = 2 .0.0 SENTRY_DSN = https://boo@sentry.com/1 SENTRY_FRONTEND_CONFIG = '{\"tags\":{\"site\":\"www.test.com\",\"app\":\"test_app\"},\"extras\":{\"logger\":\"javascript-frontend\", \"release\":\"1.4.1\"}}' SENTRY_BACKEND_CONFIG = ' { \"tags\" : { \"site\" : \"www.test.com\" , \"app\" : \"test_app\" } yarn build node build/server.js Example with docker-compose: version : '3' services : volto : build : volto ports : - 3000:3000 - 3001:3001 environment : - SENTRY_URL=https://mysentry.com - SENTRY_AUTH_TOKEN=foo - SENTRY_ORG=my_organization - SENTRY_PROJECT=new_project - SENTRY_RELEASE=2.0.0 - RAZZLE_SENTRY_DSN=https://boo@sentry.com/1 - RAZZLE_SENTRY_RELEASE=2.0.0 - RAZZLE_SENTRY_FRONTEND_CONFIG={\"tags\":{\"site\":\"www.test.com\",\"app\":\"test_app\"},\"extras\":{\"logger\":\"javascript-frontend\"}} - RAZZLE_SENTRY_BACKEND_CONFIG={\"tags\":{\"site\":\"www.test.com\",\"app\":\"test_app\"},\"extras\":{\"logger\":\"javascript-backend\", \"server\":\"server#1\"}} Example of messages in SENTRY # List of messages Messages from the frontend, with it's own TAGS and ADDITIONAL DATA Messages from the backend, with it's own TAGS and ADDITIONAL DATA","title":"Using sentry"},{"location":"deploying/sentry/#integration-with-sentry","text":"","title":"Integration with SENTRY"},{"location":"deploying/sentry/#prerequisities","text":"In Sentry create a new organization, and add a project to it On the projects settings page, from Client Keys (DSN), take the SENTRY_DSN Create an API Token: on the top left corner, click on your name -> API keys and create a new token, \"project:write\" scope should be selected. Note: Instructions tested with Sentry 9.1.2","title":"Prerequisities"},{"location":"deploying/sentry/#setup","text":"Volto creates bundles of the source codes, if an error is sent to sentry, it will only show the traceback in the bundles. To have nice traceback, we have to upload the source code and source map in sentry. This doesn't have to be done manually, we can configure our volto application to do all the steps automatically. There are 2 ways to configure the application:","title":"Setup"},{"location":"deploying/sentry/#1-buildtime","text":"This can be used when the application is deployed directly on a host machine, and built locally. The configuration is done using environment variables: SENTRY_DSN - required to enable the feature SENTRY_URL - the url of sentry SENTRY_AUTH_TOKEN - the authentication token for sentry SENTRY_ORG - the name of the organization in sentry SENTRY_PROJECT -the name of the project in sentry SENTRY_RELEASE - release number SENTRY_FRONTEND_CONFIG - optional, here we can specify TAGS and ADDITIONAL DATA for the messages from the browser we send to sentry SENTRY_BACKEND_CONFIG - same as SENTRY_FRONTEND_CONFIG, but we configure the messages from the backend If these env variables are configured, when the app is built, a new release will be created in sentry, and the source code and source maps will be uploaded it. After starting the application if an error will occure, the errors will be sent to sentry, and will be linked to the specified release. Example of usage: SENTRY_URL = https://mysentry.com SENTRY_AUTH_TOKEN = foo SENTRY_ORG = my_organization SENTRY_PROJECT = new_project SENTRY_RELEASE = 2 .0.0 SENTRY_DSN = https://boo@sentry.com/1 yarn build node build/server.js","title":"1. Buildtime"},{"location":"deploying/sentry/#2-runtime","text":"Within your Volto project or a dedicated Volto add-on you can configure Sentry via settings.sentryOptions configuration key: import { settings as defaultSettings , } from '@plone/volto/config' ; const settings = { ... defaultSettings , sentryOptions : { ... defaultSettings . sentryOptions , dsn : 'https://key@sentry.io/1' , environment : 'production' , release : '1.2.3' , serverName : 'volto' , tags : { site : 'foo.bar' , app : 'test_app' , logger : 'volto' , }, extras : { key : 'value' , }, integrations : [ ... defaultSettings . sentryOptions . integrations , // new MyAwesomeIntegration() ] } }; See more about [ Sentry Custom Integrations ]( https : //docs.sentry.io/platforms/javascript/configuration/integrations) In case you plan to use the application using docker , you will not want to have the sentry setup in the docker image . The configuration for setting up sentry on runtime is very similar as how we set it up for buildtime , but with some small differences : - SENTRY_URL - the url of sentry - SENTRY_AUTH_TOKEN - the authentication token for sentry - SENTRY_ORG - the name of the organization in sentry - SENTRY_PROJECT - the name of the project in sentry - SENTRY_RELEASE - release number - RAZZLE_SENTRY_DSN - required to enable the feature - RAZZLE_SENTRY_FRONTEND_CONFIG - optional , here we can specify TAGS and ADDITIONAL DATA for the messages from the browser we send to sentry - RAZZLE_SENTRY_BACKEND_CONFIG - same as RAZZLE_SENTRY_FRONTEND_CONFIG , but we configure the messages from the backend - RAZZLE_SENTRY_RELEASE - release number , should be the same as SENTRY_RELEASE In the entrypoint of our docker image we have to add the . / create - sentry - release . sh script . When the container is started , this script will check in sentry if the specified release already exists , if not , it will create it and upload the source code and the source maps . The script can be executed also manually and if we want to overwrite the existing files in sentry , we can use the -- force flag : ```bash ./create-sentry-release.sh --force Example of entrypoint: #!/usr/bin/env bash set -Ex function apply_path { mainjs = ./build/server.js bundlejs = ./build/public/static/js/*.js test -f $mainjs echo \"Check that we have API_PATH and API vars\" test -n \" $API_PATH \" sed -i \"s#VOLTO_API_PATH# ${ API_PATH } #g\" $mainjs sed -i \"s#VOLTO_API_PATH# ${ API_PATH } #g\" $bundlejs sed -i \"s#VOLTO_INTERNAL_API_PATH# ${ INTERNAL_API_PATH } #g\" $mainjs sed -i \"s#VOLTO_INTERNAL_API_PATH# ${ INTERNAL_API_PATH } #g\" $bundlejs gzip -fk $mainjs } # Should we monkey patch? test -n \" $API_PATH \" && apply_path ./create-sentry-release.sh echo \"Starting Volto\" exec \" $@ \" Starting with docker: docker run -p 3000 :3000 -p 3001 :3001 -e SENTRY_URL = https://mysentry.com -e SENTRY_AUTH_TOKEN = foo -e SENTRY_ORG = my_organization -e SENTRY_PROJECT = new_project -e SENTRY_RELEASE = 2 .0.0 -e RAZZLE_SENTRY_DSN = https://boo@sentry.com/1 -e RAZZLE_SENTRY_RELEASE = 2 .0.0 volto-app:latest Or using docker-compose: version : '3' services : volto : build : volto ports : - 3000:3000 - 3001:3001 environment : - SENTRY_URL=https://mysentry.com - SENTRY_AUTH_TOKEN=foo - SENTRY_ORG=my_organization - SENTRY_PROJECT=new_project - SENTRY_RELEASE=2.0.0 - RAZZLE_SENTRY_DSN=https://boo@sentry.com/1 - RAZZLE_SENTRY_RELEASE=2.0.0","title":"2. Runtime"},{"location":"deploying/sentry/#configuration-options","text":"This applies to both SENTRY_FRONTEND_CONFIG and SENTRY_BACKEND_CONFIG Note: In case you are using buildtime configuration you have to use SENTRY_FRONTEND_CONFIG and SENTRY_BACKEND_CONFIG. But if you are using runtime configuration, use RAZZLE_SENTRY_FRONTEND_CONFIG and RAZZLE_SENTRY_BACKEND_CONFIG We have the possibility to add TAGS and ADDITIONAL DATA for our messages for categorization in SENTRY. We can configure these 2 variables separately, as we might want to separate the messages from frontend and backend. Example of configurations: { \"tags\" : { \"site\" : \"www.test.com\" , \"app\" : \"test_app\" }, \"extras\" : { \"logger\" : \"javascript-frontend\" }, \"environment\" : \"development\" , \"serverName\" : \"server #1\" , \"maxBreadcrumbs\" : 50 } Example of usage with buildtime setup: SENTRY_URL = https://mysentry.com SENTRY_AUTH_TOKEN = foo SENTRY_ORG = my_organization SENTRY_PROJECT = new_project SENTRY_RELEASE = 2 .0.0 SENTRY_DSN = https://boo@sentry.com/1 SENTRY_FRONTEND_CONFIG = '{\"tags\":{\"site\":\"www.test.com\",\"app\":\"test_app\"},\"extras\":{\"logger\":\"javascript-frontend\", \"release\":\"1.4.1\"}}' SENTRY_BACKEND_CONFIG = ' { \"tags\" : { \"site\" : \"www.test.com\" , \"app\" : \"test_app\" } yarn build node build/server.js Example with docker-compose: version : '3' services : volto : build : volto ports : - 3000:3000 - 3001:3001 environment : - SENTRY_URL=https://mysentry.com - SENTRY_AUTH_TOKEN=foo - SENTRY_ORG=my_organization - SENTRY_PROJECT=new_project - SENTRY_RELEASE=2.0.0 - RAZZLE_SENTRY_DSN=https://boo@sentry.com/1 - RAZZLE_SENTRY_RELEASE=2.0.0 - RAZZLE_SENTRY_FRONTEND_CONFIG={\"tags\":{\"site\":\"www.test.com\",\"app\":\"test_app\"},\"extras\":{\"logger\":\"javascript-frontend\"}} - RAZZLE_SENTRY_BACKEND_CONFIG={\"tags\":{\"site\":\"www.test.com\",\"app\":\"test_app\"},\"extras\":{\"logger\":\"javascript-backend\", \"server\":\"server#1\"}}","title":"Configuration options"},{"location":"deploying/sentry/#example-of-messages-in-sentry","text":"List of messages Messages from the frontend, with it's own TAGS and ADDITIONAL DATA Messages from the backend, with it's own TAGS and ADDITIONAL DATA","title":"Example of messages in SENTRY"},{"location":"deploying/simple/","text":"Simple deployment # Volto is a Node application that runs on your machine/server and listens to a port. Once you are ready to deploy it, you should build it running: $ yarn build The Volto configuration determines the external URL Volto will be served, so if you just issue this command, the build will get that values and build an static bundle with that values (PORT=3000, API_PATH= http://localhost:8080/Plone ). In order to make Volto work on a server under an specific DNS name, you must parametrize the build like: $ PORT = volto_node_process_port RAZZLE_API_PATH = https://mywebsite.com/api yarn build After the build, the bundle is created in /build folder, then in order to launch your application you can run: $ yarn start:prod or $ NODE_ENV = production node build/server.js This will start Volto in the PORT specified in the build command, and will issue internal API queries to the RAZZLE_API_PATH specified as well. The simplest deployment is to start this node process in your server by any mean of your choice (systemd, process manager, etc) and manage its lifecycle. Reverse proxies # You need to make available to your users both Volto and the API in public URLs. It's heavily recommended you serve both from the same DNS name, eg. Volto-> https://mywebsite.com and API-> https://mywebsite.com/api in order to avoid any CORS problem. Warning Avoid dealing with CORS in production at all costs. Period. For SSL support is recommended to use a reverse proxy of your choice that points to Volto port and an API rewrite eg. /api in your server. This is the Nginx configuration: upstream volto { server localhost : 3000 ; } upstream ploneapi { server localhost : 8080 ; } location ~ /api($|/.*) { rewrite ^/api( $|/.* ) /VirtualHostBase/https/mywebsite.com:443/Plone/VirtualHostRoot/_vh_api $1 break ; proxy_pass http://ploneapi ; } location ~ / { # Default set to 1m - this is mainly to make PSI happy, adjust to your needs location ~ * \\.(ico|jpg|jpeg|png|gif|svg|js|jsx|css|less|swf|eot|ttf|otf|woff|woff2) $ { add_header Cache-Control \"public\" ; expires +1m ; proxy_pass http://volto ; }","title":"Simple deployment"},{"location":"deploying/simple/#simple-deployment","text":"Volto is a Node application that runs on your machine/server and listens to a port. Once you are ready to deploy it, you should build it running: $ yarn build The Volto configuration determines the external URL Volto will be served, so if you just issue this command, the build will get that values and build an static bundle with that values (PORT=3000, API_PATH= http://localhost:8080/Plone ). In order to make Volto work on a server under an specific DNS name, you must parametrize the build like: $ PORT = volto_node_process_port RAZZLE_API_PATH = https://mywebsite.com/api yarn build After the build, the bundle is created in /build folder, then in order to launch your application you can run: $ yarn start:prod or $ NODE_ENV = production node build/server.js This will start Volto in the PORT specified in the build command, and will issue internal API queries to the RAZZLE_API_PATH specified as well. The simplest deployment is to start this node process in your server by any mean of your choice (systemd, process manager, etc) and manage its lifecycle.","title":"Simple deployment"},{"location":"deploying/simple/#reverse-proxies","text":"You need to make available to your users both Volto and the API in public URLs. It's heavily recommended you serve both from the same DNS name, eg. Volto-> https://mywebsite.com and API-> https://mywebsite.com/api in order to avoid any CORS problem. Warning Avoid dealing with CORS in production at all costs. Period. For SSL support is recommended to use a reverse proxy of your choice that points to Volto port and an API rewrite eg. /api in your server. This is the Nginx configuration: upstream volto { server localhost : 3000 ; } upstream ploneapi { server localhost : 8080 ; } location ~ /api($|/.*) { rewrite ^/api( $|/.* ) /VirtualHostBase/https/mywebsite.com:443/Plone/VirtualHostRoot/_vh_api $1 break ; proxy_pass http://ploneapi ; } location ~ / { # Default set to 1m - this is mainly to make PSI happy, adjust to your needs location ~ * \\.(ico|jpg|jpeg|png|gif|svg|js|jsx|css|less|swf|eot|ttf|otf|woff|woff2) $ { add_header Cache-Control \"public\" ; expires +1m ; proxy_pass http://volto ; }","title":"Reverse proxies"},{"location":"design-principles/","text":"Design principles # Since the very beginning, Volto has been developed with a set of principles in mind, brought from the years of experience developing Plone core and implementing projects on it. Approachability Developer experience first Customization and extensibility Volto UI/UX is Pastanaga UI Do not overengineer things Each feature has only one way of doing it Frontend and backend are meant to be decoupled Focus on the UI/UX implementation and upcoming challenges Semantic versioning Following you can find the reasoning behind these principles. Approachability # Volto has to be 100% approachable by someone with zero Plone or Python knowledge. This is the main Volto principle. That means this someone has to be able to run, test and use Volto (and thus Plone), and ultimatelly customize a simple project without any problem and without having to touch Plone by any means or write a single line of Python nor implement a single Plone add-on product. This person has to be able of using only JavaScript to parameterize it. The rationale behind this is to be able to attract people from the React community or other communities and drag them to use and know Plone using Volto as a facilitator. This way we keep the existing learning curve coming from Plone away from Volto, so Volto can make (and control) from scratch its own learning curve, without any inherited burden. A number of decisions have been made based on this directive. To give an example, that's why it was decided not to use the tiles implementation and definitions existing in the Plone ecosystem. We started to do it, but all of a sudden it felt like duplicating efforts by defining them on both sides, while clearly, having them defined on Plone didn't give any value. Developer experience first # Developing in Volto has to be fun, not a burden. Implementing or customizing anything in Volto (or in a Volto project) should be easy and straightforward, and done in a single, simple way. Developing for Plone has become a burden, even doing the most simple thing often implies teaching several other things and technologies, and explain the reasoning (and the history!) behind why it is like that, and worse, often say sorry about it. Those who teach Plone out there know it's like this. Almost twenty years of history, thousands of different developers, improvements, deprecations, introduction of new technologies, and removal of them in such a big and old project is normal it's like it is, nobody is to take the blame on it. In Volto we have a blank page in front of us. Let's work to keep it clean and shiny. Customization and extensibility # Volto should ensure customization every core component via \"component shadowing\", whenever it is possible. Extensibility should also be a requirement on Volto core and in every new added feature, whenever it applies. Volto have to ensure that it can be \"pluggable\" and provide enough \"insertion points\" providing addons a way to extend or enhance the core features. However, Volto core should not be at the service of the add-ons, nor compromise any of the other manifesto points because of it. Volto UI/UX is Pastanaga UI # Volto has its own UI/UX design, it's Pastanaga UI. It was conceived from scratch to match nowadays trends and to give fresh air what a content management system user experience should be. Do not overengineer things # In the Plone community we had a tendency to overengineer things. We have the chance to stop doing it. While developing Volto we live in the Web Technologies world, let's use them in a simple and straightforward way. Do not try to implement ZCA, Portlets or five way adapters for widgets in JS. Each feature has only one way of doing it # We won't introduce (at least willingly) several ways of doing the same thing. Then you have to document them both, and explain to the user which is the best. Especially in cases where you do something in the backend or in the frontend. Frontend and backend are meant to be decoupled # So let's them keep them decoupled. In the future, while developing Volto and in our Volto projects, we will face a lot of decisions and answer questions like: What is the value to define something in the backend? Is that going to improve the (frontend) developer experience? Is separating this going to do any good or will it force us to repeat ourselves? or worse, it would take two people (frontend dev and a backend dev) to accomplish a simple task? Are we introducing two different ways of doing things? Focus on the UI/UX implementation and upcoming challenges # Volto is a frontend UI implementation of a CMS backend. We need to focus on this instead of focusing on the relationship with the backend(s). JS world advances quick, and we have to keep pace with it. React's own async (Suspense) mode it's on its way, and that will change enough things in React world and we have to keep up with these changes. Semantic versioning # Volto follows semantic versioning policy. So everybody can easily tell if a released version contains a breaking change, a feature or a minor fix.","title":"Design principles"},{"location":"design-principles/#design-principles","text":"Since the very beginning, Volto has been developed with a set of principles in mind, brought from the years of experience developing Plone core and implementing projects on it. Approachability Developer experience first Customization and extensibility Volto UI/UX is Pastanaga UI Do not overengineer things Each feature has only one way of doing it Frontend and backend are meant to be decoupled Focus on the UI/UX implementation and upcoming challenges Semantic versioning Following you can find the reasoning behind these principles.","title":"Design principles"},{"location":"design-principles/#approachability","text":"Volto has to be 100% approachable by someone with zero Plone or Python knowledge. This is the main Volto principle. That means this someone has to be able to run, test and use Volto (and thus Plone), and ultimatelly customize a simple project without any problem and without having to touch Plone by any means or write a single line of Python nor implement a single Plone add-on product. This person has to be able of using only JavaScript to parameterize it. The rationale behind this is to be able to attract people from the React community or other communities and drag them to use and know Plone using Volto as a facilitator. This way we keep the existing learning curve coming from Plone away from Volto, so Volto can make (and control) from scratch its own learning curve, without any inherited burden. A number of decisions have been made based on this directive. To give an example, that's why it was decided not to use the tiles implementation and definitions existing in the Plone ecosystem. We started to do it, but all of a sudden it felt like duplicating efforts by defining them on both sides, while clearly, having them defined on Plone didn't give any value.","title":"Approachability"},{"location":"design-principles/#developer-experience-first","text":"Developing in Volto has to be fun, not a burden. Implementing or customizing anything in Volto (or in a Volto project) should be easy and straightforward, and done in a single, simple way. Developing for Plone has become a burden, even doing the most simple thing often implies teaching several other things and technologies, and explain the reasoning (and the history!) behind why it is like that, and worse, often say sorry about it. Those who teach Plone out there know it's like this. Almost twenty years of history, thousands of different developers, improvements, deprecations, introduction of new technologies, and removal of them in such a big and old project is normal it's like it is, nobody is to take the blame on it. In Volto we have a blank page in front of us. Let's work to keep it clean and shiny.","title":"Developer experience first"},{"location":"design-principles/#customization-and-extensibility","text":"Volto should ensure customization every core component via \"component shadowing\", whenever it is possible. Extensibility should also be a requirement on Volto core and in every new added feature, whenever it applies. Volto have to ensure that it can be \"pluggable\" and provide enough \"insertion points\" providing addons a way to extend or enhance the core features. However, Volto core should not be at the service of the add-ons, nor compromise any of the other manifesto points because of it.","title":"Customization and extensibility"},{"location":"design-principles/#volto-uiux-is-pastanaga-ui","text":"Volto has its own UI/UX design, it's Pastanaga UI. It was conceived from scratch to match nowadays trends and to give fresh air what a content management system user experience should be.","title":"Volto UI/UX is Pastanaga UI"},{"location":"design-principles/#do-not-overengineer-things","text":"In the Plone community we had a tendency to overengineer things. We have the chance to stop doing it. While developing Volto we live in the Web Technologies world, let's use them in a simple and straightforward way. Do not try to implement ZCA, Portlets or five way adapters for widgets in JS.","title":"Do not overengineer things"},{"location":"design-principles/#each-feature-has-only-one-way-of-doing-it","text":"We won't introduce (at least willingly) several ways of doing the same thing. Then you have to document them both, and explain to the user which is the best. Especially in cases where you do something in the backend or in the frontend.","title":"Each feature has only one way of doing it"},{"location":"design-principles/#frontend-and-backend-are-meant-to-be-decoupled","text":"So let's them keep them decoupled. In the future, while developing Volto and in our Volto projects, we will face a lot of decisions and answer questions like: What is the value to define something in the backend? Is that going to improve the (frontend) developer experience? Is separating this going to do any good or will it force us to repeat ourselves? or worse, it would take two people (frontend dev and a backend dev) to accomplish a simple task? Are we introducing two different ways of doing things?","title":"Frontend and backend are meant to be decoupled"},{"location":"design-principles/#focus-on-the-uiux-implementation-and-upcoming-challenges","text":"Volto is a frontend UI implementation of a CMS backend. We need to focus on this instead of focusing on the relationship with the backend(s). JS world advances quick, and we have to keep pace with it. React's own async (Suspense) mode it's on its way, and that will change enough things in React world and we have to keep up with these changes.","title":"Focus on the UI/UX implementation and upcoming challenges"},{"location":"design-principles/#semantic-versioning","text":"Volto follows semantic versioning policy. So everybody can easily tell if a released version contains a breaking change, a feature or a minor fix.","title":"Semantic versioning"},{"location":"developer-guidelines/acceptance-tests/","text":"Acceptance tests # We use Cypress as Volto's acceptance test framework. Helper commands # There are some artifacts available for the acceptance tests made accessible to Cypress. Access History, Redux Store and Settings # We expose the History, Redux Store and Settings from the app (only for Cypress environments) so we can easily access them and execute actions (like navigate using the router), dispatch Redux actions or change app settings \"on the fly\". Navigate using React Router # You can navigate using the React Router (ie. not reloading the page) with this command: cy . navigate ( '/events' ); Redux Store # You can access the Redux store and check for specific states and dispatch actions by: import { updateIntl } from 'react-intl-redux' ; import deLocales from '../../locales/de.json' ; const dispatch = action => cy . window () . its ( 'store' ) . invoke ( 'dispatch' , action ); dispatch ( updateIntl ({ locale : 'de' , messages : deLocales , }), ); More information about this: https://www.cypress.io/blog/2018/11/14/testing-redux-store/ Volto settings # You can modify on the fly the main Volto settings like this: cy . settings (). then ( settings => { settings . defaultLanguage = 'de' ; settings . isMultilingual = true ; settings . supportedLanguages = [ 'de' , 'en' ]; });","title":"Acceptance tests"},{"location":"developer-guidelines/acceptance-tests/#acceptance-tests","text":"We use Cypress as Volto's acceptance test framework.","title":"Acceptance tests"},{"location":"developer-guidelines/acceptance-tests/#helper-commands","text":"There are some artifacts available for the acceptance tests made accessible to Cypress.","title":"Helper commands"},{"location":"developer-guidelines/acceptance-tests/#access-history-redux-store-and-settings","text":"We expose the History, Redux Store and Settings from the app (only for Cypress environments) so we can easily access them and execute actions (like navigate using the router), dispatch Redux actions or change app settings \"on the fly\".","title":"Access History, Redux Store and Settings"},{"location":"developer-guidelines/acceptance-tests/#navigate-using-react-router","text":"You can navigate using the React Router (ie. not reloading the page) with this command: cy . navigate ( '/events' );","title":"Navigate using React Router"},{"location":"developer-guidelines/acceptance-tests/#redux-store","text":"You can access the Redux store and check for specific states and dispatch actions by: import { updateIntl } from 'react-intl-redux' ; import deLocales from '../../locales/de.json' ; const dispatch = action => cy . window () . its ( 'store' ) . invoke ( 'dispatch' , action ); dispatch ( updateIntl ({ locale : 'de' , messages : deLocales , }), ); More information about this: https://www.cypress.io/blog/2018/11/14/testing-redux-store/","title":"Redux Store"},{"location":"developer-guidelines/acceptance-tests/#volto-settings","text":"You can modify on the fly the main Volto settings like this: cy . settings (). then ( settings => { settings . defaultLanguage = 'de' ; settings . isMultilingual = true ; settings . supportedLanguages = [ 'de' , 'en' ]; });","title":"Volto settings"},{"location":"developer-guidelines/accessibility-guidelines/","text":"Accessibility guidelines # Attention points to improve and maintain accessibility. In documentation, code and filenames you will often see this abbreviated as \"a11y\". Clickable elements that have a symbol or icon and no visible text # If the symbol or icon is clear enough for sighted users, for instance a big \"X\" to close a dialog, it will still need a text for screen reader users. You can achieve a 'hidden' label by setting the property \"aria-label\" on the element. If available, use the translation machinery available to make the label appear in the correct language. Example: jsx noeditor <button className=\"cancel\" aria-label=\"Cancel\" onClick={() => this.onCancel()}> <Icon name={clearSVG} className=\"circled\" size=\"30px\" title={this.props.intl.formatMessage(messages.cancel)} /> </button> Do not use <a> tags without href # If an element has an event listener on it and performs an action, but does not point to a proper URL, use a <button> and style with CSS to style. The reasoning is that the <a></a> HTML tag has specific behavior that screenreaders support and that screenreader users expect. Make sure form elements have a label # This is true for one-element forms as well, such as the \"Search\" form on the folder-contents component. Putting an icon on it does not convey any meaning to screenreader-users, you should clarify it with an aria-label.","title":"Accessibility"},{"location":"developer-guidelines/accessibility-guidelines/#accessibility-guidelines","text":"Attention points to improve and maintain accessibility. In documentation, code and filenames you will often see this abbreviated as \"a11y\".","title":"Accessibility guidelines"},{"location":"developer-guidelines/accessibility-guidelines/#clickable-elements-that-have-a-symbol-or-icon-and-no-visible-text","text":"If the symbol or icon is clear enough for sighted users, for instance a big \"X\" to close a dialog, it will still need a text for screen reader users. You can achieve a 'hidden' label by setting the property \"aria-label\" on the element. If available, use the translation machinery available to make the label appear in the correct language. Example: jsx noeditor <button className=\"cancel\" aria-label=\"Cancel\" onClick={() => this.onCancel()}> <Icon name={clearSVG} className=\"circled\" size=\"30px\" title={this.props.intl.formatMessage(messages.cancel)} /> </button>","title":"Clickable elements that have a symbol or icon and no visible text"},{"location":"developer-guidelines/accessibility-guidelines/#do-not-use-a-tags-without-href","text":"If an element has an event listener on it and performs an action, but does not point to a proper URL, use a <button> and style with CSS to style. The reasoning is that the <a></a> HTML tag has specific behavior that screenreaders support and that screenreader users expect.","title":"Do not use &lt;a&gt; tags without href"},{"location":"developer-guidelines/accessibility-guidelines/#make-sure-form-elements-have-a-label","text":"This is true for one-element forms as well, such as the \"Search\" form on the folder-contents component. Putting an icon on it does not convey any meaning to screenreader-users, you should clarify it with an aria-label.","title":"Make sure form elements have a label"},{"location":"developer-guidelines/language-features/","text":"Language features and conventions # Babel # Volto is developed using Babel to transpile modern Javascript to Javascript that browsers are able to understand and execute. Ecma International's TC39 ( https://tc39.es/ ) is a group of JavaScript developers, implementers, academics, and more, collaborating with the community to maintain and evolve the definition of JavaScript. They stablished a process ( https://tc39.es/process-document/ ) where the proposals are discussed, developed, and eventually approved (or dropped). The process has five stages (0 to 4) where reaching the stage 4 means the proposal is accepted and it becomes part of the Javascript specification. Babel enables a series of features and syntax that the developer can use in code to develop Volto on. These features are the proposals the TC39 is working on in the different stages of evolution. Volto uses babel-razzle-preset which in turns uses @babel/preset-env which enables the use of all TC39 proposals currently in TC39's stage 4 ( https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md#finished-proposals ). Browser compatibility # Babel preset-env uses browserlist which gives the ability to micromanage the transformations needed by the current project depending of the browser support you are currently targeting. By doing this, enables the bundles to be smaller, as the resultant code does not need to support old browsers (thus, transform your code to ES5 compatible code) as Babel will apply only the required transforms that your target enviroments need. For more information: https://babeljs.io/docs/en/babel-preset-env#browserslist-integration Volto project generators use this browserlist by default (you can find it in your local package.json ): \"browserslist\" : [ \">1%\" , \"last 4 versions\" , \"Firefox ESR\" , \"not ie 11\" , \"not dead\" ] , which you can adjust depending on the environments you are targeting in your local package.json file. You can find more information about how the queries in broserlist works in: https://github.com/browserslist/browserslist#queries Support to deprecated browsers # Warning Volto does not support deprecated browsers from its vendor (eg. IE11). If you still need to support deprecated browsers, you should use browserslist in your project to enable the required transforms for the target deprecated environments you have to support. However, Volto (or its dependencies) might not be compatible with old browsers anyways, and you might need to provide some other workarounds to make the build work (and the deprecated browser not crash). You can refer to this (outdated) document in order to get some hints on how to do it.","title":"Language features"},{"location":"developer-guidelines/language-features/#language-features-and-conventions","text":"","title":"Language features and conventions"},{"location":"developer-guidelines/language-features/#babel","text":"Volto is developed using Babel to transpile modern Javascript to Javascript that browsers are able to understand and execute. Ecma International's TC39 ( https://tc39.es/ ) is a group of JavaScript developers, implementers, academics, and more, collaborating with the community to maintain and evolve the definition of JavaScript. They stablished a process ( https://tc39.es/process-document/ ) where the proposals are discussed, developed, and eventually approved (or dropped). The process has five stages (0 to 4) where reaching the stage 4 means the proposal is accepted and it becomes part of the Javascript specification. Babel enables a series of features and syntax that the developer can use in code to develop Volto on. These features are the proposals the TC39 is working on in the different stages of evolution. Volto uses babel-razzle-preset which in turns uses @babel/preset-env which enables the use of all TC39 proposals currently in TC39's stage 4 ( https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md#finished-proposals ).","title":"Babel"},{"location":"developer-guidelines/language-features/#browser-compatibility","text":"Babel preset-env uses browserlist which gives the ability to micromanage the transformations needed by the current project depending of the browser support you are currently targeting. By doing this, enables the bundles to be smaller, as the resultant code does not need to support old browsers (thus, transform your code to ES5 compatible code) as Babel will apply only the required transforms that your target enviroments need. For more information: https://babeljs.io/docs/en/babel-preset-env#browserslist-integration Volto project generators use this browserlist by default (you can find it in your local package.json ): \"browserslist\" : [ \">1%\" , \"last 4 versions\" , \"Firefox ESR\" , \"not ie 11\" , \"not dead\" ] , which you can adjust depending on the environments you are targeting in your local package.json file. You can find more information about how the queries in broserlist works in: https://github.com/browserslist/browserslist#queries","title":"Browser compatibility"},{"location":"developer-guidelines/language-features/#support-to-deprecated-browsers","text":"Warning Volto does not support deprecated browsers from its vendor (eg. IE11). If you still need to support deprecated browsers, you should use browserslist in your project to enable the required transforms for the target deprecated environments you have to support. However, Volto (or its dependencies) might not be compatible with old browsers anyways, and you might need to provide some other workarounds to make the build work (and the deprecated browser not crash). You can refer to this (outdated) document in order to get some hints on how to do it.","title":"Support to deprecated browsers"},{"location":"developer-guidelines/linting/","text":"Linting # Note This documentation is a work in progress. Any help is welcome to fill in the gaps! Volto developers can enjoy a lot of freedom in their choice of text editors and IDEs, thanks to the strong tooling provided by the Javascript ecosystem. At the core of these capabilities is ESLint, the advanced javascript linting and formatting tool. Also included with Volto is integration with Stylelint and Prettier. For Visual Studio Code you'll need to integrate an ESLint plugin . For VIM you can use the awesome ALE , which provides out-of-the box integration with all the tooling provided by Volto. Use this checklist to make sure your editor integration is properly integrated, most importantly for .js/jsx files: The editor should automatically flag syntax errors The editor should automatically flag unused imports The editor should automatically (and properly) flag imported modules that are not found The editor should provide automatic code formatting on save","title":"Linting"},{"location":"developer-guidelines/linting/#linting","text":"Note This documentation is a work in progress. Any help is welcome to fill in the gaps! Volto developers can enjoy a lot of freedom in their choice of text editors and IDEs, thanks to the strong tooling provided by the Javascript ecosystem. At the core of these capabilities is ESLint, the advanced javascript linting and formatting tool. Also included with Volto is integration with Stylelint and Prettier. For Visual Studio Code you'll need to integrate an ESLint plugin . For VIM you can use the awesome ALE , which provides out-of-the box integration with all the tooling provided by Volto. Use this checklist to make sure your editor integration is properly integrated, most importantly for .js/jsx files: The editor should automatically flag syntax errors The editor should automatically flag unused imports The editor should automatically (and properly) flag imported modules that are not found The editor should provide automatic code formatting on save","title":"Linting"},{"location":"developer-guidelines/react/","text":"React # Note This documentation is a work in progress. Any help is welcome to fill in the gaps!","title":"React"},{"location":"developer-guidelines/react/#react","text":"Note This documentation is a work in progress. Any help is welcome to fill in the gaps!","title":"React"},{"location":"developer-guidelines/redux/","text":"Redux # Note This documentation is a work in progress. Any help is welcome to fill in the gaps! As with any other complex React project, the way global state is handled across all components has a big impact on the overall architecture. Basic knowledge of Redux is needed to understand this part, but Volto's use of Redux is \"typical\" and you can find plenty examples in Volto's code base. To access the global state, a component needs to be connected with connect . A simple example of such component is the src/theme/ContactForm/ContactForm.jsx , which is exported connected as: export default compose( withRouter, injectIntl, connect( (state, props) => ({ loading: state.emailNotification.loading, loaded: state.emailNotification.loaded, error: state.emailNotification.error, pathname: props.location.pathname, }), { emailNotification }, ), )(ContactForm); If multiple Higher Order Components need to be used, like in the above example, the compose can be used to combine all of them in a final component. If you're writing Function Components, you can use the useSelector hook. See src/components/theme/OutdatedBrowser/OutdatedBrowser.jsx for an example. When using the connect function, you can select parts from the global store and either pass them directly as component props, or tweak them combine them, etc. You can view the content of the global Redux store by using a browser Redux developer extension . The code that is used to populate this store is in the src/reducers folder. In some parts of Volto you'll see asyncConnect being used, which is needed to enable proper server-side rendering of components. Using it makes sure that the component will be constructed with the proper data already fetched from the backend and available as props. Note Beware! The asyncConnect is available only to components that are attached directly to the router or its children. There are some components that decide their \"rendering path\" at render time, so this prohibits the use of asyncConnect in that component tree. The biggest example of this is src/theme/View/View.jsx which decides on the render component based inspecting the content, so it is not possible to use asyncConnect in any view/layout component! Notice the emailNotification action being passed to connect in the above example. All action (which trigger global state updates) need to be passed as props by connect . You can't properly trigger an action unless you access it as a prop, for example this.props.emailNotification() . For Function Components you can use the useDispatch hook. Global state update fetches are typically triggered by components in the mount lifecycle stage. See for example src/components/theme/Search/Search.jsx for a component that needs to interact with the backend to show its content. In the redux flow of information, actions trigger the asynchronous processes and when that content arrives to the global app, it is pushed as props through the connect mechanism. So components only deal indirectly with async information: they trigger getting that information and it will arrive as a property once it is ready. Backend network fetching # Backend network fetches are automatically triggered by creating a Redux action with a request key. For a simple example, see src/actions/navigation/navigation.js . In the request key you can set the HTTP method type (using the op field) and the path to the backend. Any non-absolute URLs are use the settings.apiPath prefix, but you can query any other backend server by using a URL that starts with http:// or https:// . When writing the reducer counterpart, you'll get the backend response available as action.result . It's also possible to make multiple backend requests at once, for example to batch create content. In that case, set the action.request to be a list of objects (requests) and consequently, in the reducer, the action.result will be a list of responses corresponding to each request. See the src/reducers/content for an example. In order to make them more generic and allow more reuse, some actions can accept a subrequest parameter, basically a string that can identify the response and \"namespace\" it in the global state. See for example the content reducer. Using subrequest is specially important when using the getContent action, as, without it, it would overwrite the global state.content store with possible wrong content for the current context. Creating a \"request action\" potentially triggers some additional access. For example, even if we only declare the GET_CONTENT type of action, we can see that GET_CONTENT_SUCCESS , GET_CONTENT_PENDING and GET_CONTENT_FAIL are also used in the content reducer. They are automatically created by the special Api middleware, available in src/middleware/api.js .","title":"Redux"},{"location":"developer-guidelines/redux/#redux","text":"Note This documentation is a work in progress. Any help is welcome to fill in the gaps! As with any other complex React project, the way global state is handled across all components has a big impact on the overall architecture. Basic knowledge of Redux is needed to understand this part, but Volto's use of Redux is \"typical\" and you can find plenty examples in Volto's code base. To access the global state, a component needs to be connected with connect . A simple example of such component is the src/theme/ContactForm/ContactForm.jsx , which is exported connected as: export default compose( withRouter, injectIntl, connect( (state, props) => ({ loading: state.emailNotification.loading, loaded: state.emailNotification.loaded, error: state.emailNotification.error, pathname: props.location.pathname, }), { emailNotification }, ), )(ContactForm); If multiple Higher Order Components need to be used, like in the above example, the compose can be used to combine all of them in a final component. If you're writing Function Components, you can use the useSelector hook. See src/components/theme/OutdatedBrowser/OutdatedBrowser.jsx for an example. When using the connect function, you can select parts from the global store and either pass them directly as component props, or tweak them combine them, etc. You can view the content of the global Redux store by using a browser Redux developer extension . The code that is used to populate this store is in the src/reducers folder. In some parts of Volto you'll see asyncConnect being used, which is needed to enable proper server-side rendering of components. Using it makes sure that the component will be constructed with the proper data already fetched from the backend and available as props. Note Beware! The asyncConnect is available only to components that are attached directly to the router or its children. There are some components that decide their \"rendering path\" at render time, so this prohibits the use of asyncConnect in that component tree. The biggest example of this is src/theme/View/View.jsx which decides on the render component based inspecting the content, so it is not possible to use asyncConnect in any view/layout component! Notice the emailNotification action being passed to connect in the above example. All action (which trigger global state updates) need to be passed as props by connect . You can't properly trigger an action unless you access it as a prop, for example this.props.emailNotification() . For Function Components you can use the useDispatch hook. Global state update fetches are typically triggered by components in the mount lifecycle stage. See for example src/components/theme/Search/Search.jsx for a component that needs to interact with the backend to show its content. In the redux flow of information, actions trigger the asynchronous processes and when that content arrives to the global app, it is pushed as props through the connect mechanism. So components only deal indirectly with async information: they trigger getting that information and it will arrive as a property once it is ready.","title":"Redux"},{"location":"developer-guidelines/redux/#backend-network-fetching","text":"Backend network fetches are automatically triggered by creating a Redux action with a request key. For a simple example, see src/actions/navigation/navigation.js . In the request key you can set the HTTP method type (using the op field) and the path to the backend. Any non-absolute URLs are use the settings.apiPath prefix, but you can query any other backend server by using a URL that starts with http:// or https:// . When writing the reducer counterpart, you'll get the backend response available as action.result . It's also possible to make multiple backend requests at once, for example to batch create content. In that case, set the action.request to be a list of objects (requests) and consequently, in the reducer, the action.result will be a list of responses corresponding to each request. See the src/reducers/content for an example. In order to make them more generic and allow more reuse, some actions can accept a subrequest parameter, basically a string that can identify the response and \"namespace\" it in the global state. See for example the content reducer. Using subrequest is specially important when using the getContent action, as, without it, it would overwrite the global state.content store with possible wrong content for the current context. Creating a \"request action\" potentially triggers some additional access. For example, even if we only declare the GET_CONTENT type of action, we can see that GET_CONTENT_SUCCESS , GET_CONTENT_PENDING and GET_CONTENT_FAIL are also used in the content reducer. They are automatically created by the special Api middleware, available in src/middleware/api.js .","title":"Backend network fetching"},{"location":"developer-guidelines/routing/","text":"Routing # Note This documentation is a work in progress. Any help is welcome to fill in the gaps!","title":"Routing"},{"location":"developer-guidelines/routing/#routing","text":"Note This documentation is a work in progress. Any help is welcome to fill in the gaps!","title":"Routing"},{"location":"developer-guidelines/testing/","text":"Testing # We use Jest for unit testing in Volto. The popular @testing-library/react is also available for writing your tests. For every feature or component, a unit test is mandatory in Volto core. Jest configuration # Jest is configured in package.json , under the \"jest\" key. Jest configuration override # In CI or for testing addons, it's interesting to provide an alternate Jest configuration or slightly modify it. Volto provide a way to do it using a jest.config.js file or pointing the test runner to a file of your choice, using RAZZLE_JEST_CONFIG environment variable. RAZZLE_JEST_CONFIG=my-custom-jest-config.js yarn test Note Both configurations are merged in a way that the keys of the config provided override the initial ( package.json ) default config, either in Volto or in your projects. This is specially useful in CI while developing add-ons, so you can pass an specific configuration that deals with the addon config properly.","title":"Testing"},{"location":"developer-guidelines/testing/#testing","text":"We use Jest for unit testing in Volto. The popular @testing-library/react is also available for writing your tests. For every feature or component, a unit test is mandatory in Volto core.","title":"Testing"},{"location":"developer-guidelines/testing/#jest-configuration","text":"Jest is configured in package.json , under the \"jest\" key.","title":"Jest configuration"},{"location":"developer-guidelines/testing/#jest-configuration-override","text":"In CI or for testing addons, it's interesting to provide an alternate Jest configuration or slightly modify it. Volto provide a way to do it using a jest.config.js file or pointing the test runner to a file of your choice, using RAZZLE_JEST_CONFIG environment variable. RAZZLE_JEST_CONFIG=my-custom-jest-config.js yarn test Note Both configurations are merged in a way that the keys of the config provided override the initial ( package.json ) default config, either in Volto or in your projects. This is specially useful in CI while developing add-ons, so you can pass an specific configuration that deals with the addon config properly.","title":"Jest configuration override"},{"location":"getting-started/install/","text":"Getting Started # Installing Volto # Volto can be installed in any operating system assuming that this requirements are met: Node.js LTS (14.x) Python 3.7.x / 2.7.x or Docker (if using the Plone/Guillotina docker images) Depending on the OS that you are using some of the following might change, they are assuming a MacOS/Linux machine: Install nvm (NodeJS version manager) # If you have a working nodejs development setup on your machine, this step is not required. But it's a good idea to integrate nvm for development, as it provides easy access to any Nodejs released version. Open a terminal console and type: touch ~/.bash_profile curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash Close the terminal and open a new one or execute: source ~/.bash_profile Test it: nvm version Install any active LTS version of NodeJS ( https://nodejs.org/en/about/releases/ ): nvm install 12.16.1 nvm use 12.16.1 Test NodeJS: node -v Note If you're using the fish shell, you can use nvm.fish Note Volto supports all currently active NodeJS LTS versions based on NodeJS Releases page . On 2021-04-30 Volto will not support Node 10 as it will reach its end of life. Yarn (NodeJS package manager) # Install the Yarn Classic version (not the 2.x one!), of the popular node package manager. Open a terminal and type: curl -o- -L https://yarnpkg.com/install.sh | bash Test it, running: yarn -v Tip You can install yarn using several approaches too, depending on the platform you are on. Take a look at the original yarn documentation for a list of them. Docker for Mac # In order to run the API backend, in a quick an easy and hassle way, it's recommended to start running it in a container. Here are the detailed instructions: https://hub.docker.com/editions/community/docker-ce-desktop-mac Download the .dmg from: https://download.docker.com/mac/stable/Docker.dmg Install the package as any other Mac software, if required, follow instructions from: https://docs.docker.com/docker-for-mac/install/ Check that docker is installed correctly, open a new terminal and type: docker ps should not throw an error and show the current running containers. Get Plone ready for Volto # In order to fully support all Volto features, Plone needs to be prepared for Volto. This involves configuration, add-ons installation and some patches to the core. There's a package published called kitconcept.volto that does all the heavy lifting for you and it's ready to use in your own projects. Note However, this package is oppinionated and might not fit your needs, so if you want to use your own integration package instead, just take a look to the features it provides and extract the ones you need for your project and tailor your own integration package. https://github.com/kitconcept/kitconcept.volto Tip From Volto 5.1 and above, Volto features an internal proxy to your API server. So you don't have to deal with CORS. It's enabled by default, pointing to the server specified in the devProxyToApiPath Volto settings ( http://localhost:8080/Plone ). See here for more details. Run a Volto ready Plone Docker container # You can run an standard Plone docker container with the proper configuration using kitconcept.volto right away by issuing: docker run -it --rm --name = plone \\ -p 8080 :8080 -e SITE = Plone -e ADDONS = \"kitconcept.volto\" \\ -e ZCML = \"kitconcept.volto.cors\" \\ -e PROFILES = \"kitconcept.volto:default-homepage\" \\ plone Install Volto # Use the create-volto-app helper utility. Open a terminal and execute: npm -g i @plone/create-volto-app Create a new Volto app using the recently added command, providing the name of the new app (folder) to be created. create-volto-app myvoltoapp Change directory to the newly created folder myvoltoapp (or the one you've chosen): cd myvoltoapp Then start Volto with: yarn start This command will build an in-memory bundle and execute Volto in development mode. Open a browser to take a look at http://localhost:3000 Tip The Volto developer community is working on a new enhanced generator . In addition to bootstrapping standalone Volto projects, it can also bootstrap Volto addons. Give it a try! Build the production bundle # In production environments, you should build an static version of your (Volto) app. The app should be run in a node process (because of the server side rendering part), but it also have a client part that is provided and deployed by the server side rendering process. Compile the app using the command: yarn build The resultant build is available in the build folder. Run the Volto Nodejs process yarn start:prod to run the node process with the production build. You can also run it manually: NODE_ENV=production node build/server.js Your production ready Volto will be available in http://localhost:3000","title":"Bootstrap Volto"},{"location":"getting-started/install/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/install/#installing-volto","text":"Volto can be installed in any operating system assuming that this requirements are met: Node.js LTS (14.x) Python 3.7.x / 2.7.x or Docker (if using the Plone/Guillotina docker images) Depending on the OS that you are using some of the following might change, they are assuming a MacOS/Linux machine:","title":"Installing Volto"},{"location":"getting-started/install/#install-nvm-nodejs-version-manager","text":"If you have a working nodejs development setup on your machine, this step is not required. But it's a good idea to integrate nvm for development, as it provides easy access to any Nodejs released version. Open a terminal console and type: touch ~/.bash_profile curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash Close the terminal and open a new one or execute: source ~/.bash_profile Test it: nvm version Install any active LTS version of NodeJS ( https://nodejs.org/en/about/releases/ ): nvm install 12.16.1 nvm use 12.16.1 Test NodeJS: node -v Note If you're using the fish shell, you can use nvm.fish Note Volto supports all currently active NodeJS LTS versions based on NodeJS Releases page . On 2021-04-30 Volto will not support Node 10 as it will reach its end of life.","title":"Install nvm (NodeJS version manager)"},{"location":"getting-started/install/#yarn-nodejs-package-manager","text":"Install the Yarn Classic version (not the 2.x one!), of the popular node package manager. Open a terminal and type: curl -o- -L https://yarnpkg.com/install.sh | bash Test it, running: yarn -v Tip You can install yarn using several approaches too, depending on the platform you are on. Take a look at the original yarn documentation for a list of them.","title":"Yarn (NodeJS package manager)"},{"location":"getting-started/install/#docker-for-mac","text":"In order to run the API backend, in a quick an easy and hassle way, it's recommended to start running it in a container. Here are the detailed instructions: https://hub.docker.com/editions/community/docker-ce-desktop-mac Download the .dmg from: https://download.docker.com/mac/stable/Docker.dmg Install the package as any other Mac software, if required, follow instructions from: https://docs.docker.com/docker-for-mac/install/ Check that docker is installed correctly, open a new terminal and type: docker ps should not throw an error and show the current running containers.","title":"Docker for Mac"},{"location":"getting-started/install/#get-plone-ready-for-volto","text":"In order to fully support all Volto features, Plone needs to be prepared for Volto. This involves configuration, add-ons installation and some patches to the core. There's a package published called kitconcept.volto that does all the heavy lifting for you and it's ready to use in your own projects. Note However, this package is oppinionated and might not fit your needs, so if you want to use your own integration package instead, just take a look to the features it provides and extract the ones you need for your project and tailor your own integration package. https://github.com/kitconcept/kitconcept.volto Tip From Volto 5.1 and above, Volto features an internal proxy to your API server. So you don't have to deal with CORS. It's enabled by default, pointing to the server specified in the devProxyToApiPath Volto settings ( http://localhost:8080/Plone ). See here for more details.","title":"Get Plone ready for Volto"},{"location":"getting-started/install/#run-a-volto-ready-plone-docker-container","text":"You can run an standard Plone docker container with the proper configuration using kitconcept.volto right away by issuing: docker run -it --rm --name = plone \\ -p 8080 :8080 -e SITE = Plone -e ADDONS = \"kitconcept.volto\" \\ -e ZCML = \"kitconcept.volto.cors\" \\ -e PROFILES = \"kitconcept.volto:default-homepage\" \\ plone","title":"Run a Volto ready Plone Docker container"},{"location":"getting-started/install/#install-volto","text":"Use the create-volto-app helper utility. Open a terminal and execute: npm -g i @plone/create-volto-app Create a new Volto app using the recently added command, providing the name of the new app (folder) to be created. create-volto-app myvoltoapp Change directory to the newly created folder myvoltoapp (or the one you've chosen): cd myvoltoapp Then start Volto with: yarn start This command will build an in-memory bundle and execute Volto in development mode. Open a browser to take a look at http://localhost:3000 Tip The Volto developer community is working on a new enhanced generator . In addition to bootstrapping standalone Volto projects, it can also bootstrap Volto addons. Give it a try!","title":"Install Volto"},{"location":"getting-started/install/#build-the-production-bundle","text":"In production environments, you should build an static version of your (Volto) app. The app should be run in a node process (because of the server side rendering part), but it also have a client part that is provided and deployed by the server side rendering process. Compile the app using the command: yarn build The resultant build is available in the build folder. Run the Volto Nodejs process yarn start:prod to run the node process with the production build. You can also run it manually: NODE_ENV=production node build/server.js Your production ready Volto will be available in http://localhost:3000","title":"Build the production bundle"},{"location":"getting-started/others/","text":"Other learning resources # On the Plone Trainings Website you'll find Volto-dedicated open training materials plus React and other Javascript-centered trainings. PloneConf 2019 # PloneConf 2019 had several Volto-relevant presentations. Howtos # Rob Gietema - How to create your own Volto site! Rodrigo Ferreira de Souza - Data migration to Plone 5.2 and Volto Panels and discussions # Timo Stollenwerk - Breaking New Grounds Panel - Ask me anything on Volto Luca Pisani - Plone and React.js: An interview to Volto Victor Fernandez de Alba - Plone Beyond 2020: Jump into Volto today! Nicola Zambello - A Volto story: building a website by prototyping","title":"Learning resources"},{"location":"getting-started/others/#other-learning-resources","text":"On the Plone Trainings Website you'll find Volto-dedicated open training materials plus React and other Javascript-centered trainings.","title":"Other learning resources"},{"location":"getting-started/others/#ploneconf-2019","text":"PloneConf 2019 had several Volto-relevant presentations.","title":"PloneConf 2019"},{"location":"getting-started/others/#howtos","text":"Rob Gietema - How to create your own Volto site! Rodrigo Ferreira de Souza - Data migration to Plone 5.2 and Volto","title":"Howtos"},{"location":"getting-started/others/#panels-and-discussions","text":"Timo Stollenwerk - Breaking New Grounds Panel - Ask me anything on Volto Luca Pisani - Plone and React.js: An interview to Volto Victor Fernandez de Alba - Plone Beyond 2020: Jump into Volto today! Nicola Zambello - A Volto story: building a website by prototyping","title":"Panels and discussions"},{"location":"getting-started/roadmap/","text":"Developer roadmap # If you're coming to Volto as a backend Plone developer, you'll have to learn and adjust to the new frontend-centered development. But if you already have some frontend development experience any JS frameworks such as AngularJS, Vue or React, you'll find that Volto is a relatively shallow framework, structured as a typical Redux-centered React application. Although there will be Volto-specific knowledge to be gained along the way, you can be productive in a short time. As a reference, here's an overview of knowledge and frameworks, for a more complete and accurate picture of the Volto framework. The foundation # As is the case with similar modern Javascript-based applications, you should know: Modern Javascript development. Volto uses next-generation Javascript. Follow the ES6 guide to get up to speed. React knowledge - basic level is fine for the beginning, you'll progress along the way. React itself is a simple and well documented framework. A basic understanding of Javascript CommonJS , NPM packages , Yarn , Babel and Webpack . Basic Volto development # Once you've bootstrapped your Volto project you can already start hacking. Some of the things you can do at this stage: Configure your text editor for Javascript and Volto development Volto project-based development Understand and debug React errors Understand React component lifecycle Customize (shadow) Volto's builtin components Write a new block Adjust Volto's builtin settings Extend the Pastanaga theme Extend the richtext editor capabilities with new buttons and styles Use the Redux store Deploy your first project After you've mastered the foundation and basic Volto development, the learning-curve smoothes out. Volto uses simple and familiar concepts, there is nothing on the level of ZCA that needs to be internalized before you can be really productive. Normal, everyday Volto development # Write new Redux actions and reducers Create new views for Plone content. Install and integrate new Javascript libraries or third-party React components Create a new Volto addon Integrate addon LESS with Volto's theme variables Use schema-based forms to write block components Write new form widgets Write tests for jest Write integration tests for Cypress Split your code and lazy-load libraries, to improve performance Use more advanced React concepts: hooks, context providers, etc. Make your code reusable, separate business logic and repeated behaviors as Higher Order Components (HOCs) Write extensible blocks Advanced # Not really advanced but perhaps less common, here's some stuff you can do: Provide backend-based integration to your Volto code, write plone.restapi endpoints, adapters and other extensions Custom integration for blocks to the backend using the block transfomers concept Write Express middleware for Volto's server Customize Volto's Webpack configuration or project loader using Razzle Write a Redux middleware Start hacking on Volto.","title":"Developer roadmap"},{"location":"getting-started/roadmap/#developer-roadmap","text":"If you're coming to Volto as a backend Plone developer, you'll have to learn and adjust to the new frontend-centered development. But if you already have some frontend development experience any JS frameworks such as AngularJS, Vue or React, you'll find that Volto is a relatively shallow framework, structured as a typical Redux-centered React application. Although there will be Volto-specific knowledge to be gained along the way, you can be productive in a short time. As a reference, here's an overview of knowledge and frameworks, for a more complete and accurate picture of the Volto framework.","title":"Developer roadmap"},{"location":"getting-started/roadmap/#the-foundation","text":"As is the case with similar modern Javascript-based applications, you should know: Modern Javascript development. Volto uses next-generation Javascript. Follow the ES6 guide to get up to speed. React knowledge - basic level is fine for the beginning, you'll progress along the way. React itself is a simple and well documented framework. A basic understanding of Javascript CommonJS , NPM packages , Yarn , Babel and Webpack .","title":"The foundation"},{"location":"getting-started/roadmap/#basic-volto-development","text":"Once you've bootstrapped your Volto project you can already start hacking. Some of the things you can do at this stage: Configure your text editor for Javascript and Volto development Volto project-based development Understand and debug React errors Understand React component lifecycle Customize (shadow) Volto's builtin components Write a new block Adjust Volto's builtin settings Extend the Pastanaga theme Extend the richtext editor capabilities with new buttons and styles Use the Redux store Deploy your first project After you've mastered the foundation and basic Volto development, the learning-curve smoothes out. Volto uses simple and familiar concepts, there is nothing on the level of ZCA that needs to be internalized before you can be really productive.","title":"Basic Volto development"},{"location":"getting-started/roadmap/#normal-everyday-volto-development","text":"Write new Redux actions and reducers Create new views for Plone content. Install and integrate new Javascript libraries or third-party React components Create a new Volto addon Integrate addon LESS with Volto's theme variables Use schema-based forms to write block components Write new form widgets Write tests for jest Write integration tests for Cypress Split your code and lazy-load libraries, to improve performance Use more advanced React concepts: hooks, context providers, etc. Make your code reusable, separate business logic and repeated behaviors as Higher Order Components (HOCs) Write extensible blocks","title":"Normal, everyday Volto development"},{"location":"getting-started/roadmap/#advanced","text":"Not really advanced but perhaps less common, here's some stuff you can do: Provide backend-based integration to your Volto code, write plone.restapi endpoints, adapters and other extensions Custom integration for blocks to the backend using the block transfomers concept Write Express middleware for Volto's server Customize Volto's Webpack configuration or project loader using Razzle Write a Redux middleware Start hacking on Volto.","title":"Advanced"},{"location":"introduction/introduction/","text":"Introduction to Volto # Volto is a React-based frontend for content management systems (CMS), currently supporting three backend implementations: Plone, Guillotina and a NodeJS reference implementation. Plone is a CMS built on Python born back in 2001, and unmatched experience in the subject. Plone has very interesting features that are still appealing to developers and users alike as customizable content types, hierarchical URL object traversing and a complex content workflow powered by a granular permissions model that allows you to build from simple websites to complex huge intranets. Volto exposes all that features and communicates with Plone via its mature REST API. It has the ability of being highly themable and customizable. Volto also supports other APIs like Guillotina, a Python resource management system, which is inspired on Plone using the same basic concepts like traversal, content types and permissions model. Last but not least, it also supports a Volto Nodejs-based backend reference API implementation that demos how other systems could also use Volto to display and create content through it. As any CMS, Volto is capable of take care of Server Side Rendering (SSR) in order to support SEO. Vision # Note Under construction ;) sorry for the inconvenience. Please consider to contribute to this documentation.","title":"Introduction to Volto"},{"location":"introduction/introduction/#introduction-to-volto","text":"Volto is a React-based frontend for content management systems (CMS), currently supporting three backend implementations: Plone, Guillotina and a NodeJS reference implementation. Plone is a CMS built on Python born back in 2001, and unmatched experience in the subject. Plone has very interesting features that are still appealing to developers and users alike as customizable content types, hierarchical URL object traversing and a complex content workflow powered by a granular permissions model that allows you to build from simple websites to complex huge intranets. Volto exposes all that features and communicates with Plone via its mature REST API. It has the ability of being highly themable and customizable. Volto also supports other APIs like Guillotina, a Python resource management system, which is inspired on Plone using the same basic concepts like traversal, content types and permissions model. Last but not least, it also supports a Volto Nodejs-based backend reference API implementation that demos how other systems could also use Volto to display and create content through it. As any CMS, Volto is capable of take care of Server Side Rendering (SSR) in order to support SEO.","title":"Introduction to Volto"},{"location":"introduction/introduction/#vision","text":"Note Under construction ;) sorry for the inconvenience. Please consider to contribute to this documentation.","title":"Vision"},{"location":"legacy/introduction/","text":"Volto # This is the Volto frontend implementation used by Plone and Guillotina. Components are structured in three groups: Theme is about read-only view components, Manage gathers all action components, and Mosaic .","title":"Volto"},{"location":"legacy/introduction/#volto","text":"This is the Volto frontend implementation used by Plone and Guillotina. Components are structured in three groups: Theme is about read-only view components, Manage gathers all action components, and Mosaic .","title":"Volto"},{"location":"legacy/manage/","text":"The manage group contains action components to interact with the Plone API backend. Back to the top","title":"Manage"},{"location":"legacy/mosaic/","text":"Mosaic is a new layout solution. Official depot of the plugin: github.com/plone/plone.app.mosaic Read this introduction and the package documentation for more details how to use these components. Back to the top","title":"Mosaic"},{"location":"legacy/theme/","text":"The theme group contains read-only view components to structure the page display. Back to the top","title":"Theme"},{"location":"recipes/actions-reducers/","text":"Write an action/reducer pair # Warning Please contribute this section!","title":"Write an action/reducer pair"},{"location":"recipes/actions-reducers/#write-an-actionreducer-pair","text":"Warning Please contribute this section!","title":"Write an action/reducer pair"},{"location":"recipes/appextras/","text":"AppExtras component # The AppExtras component is a general use insertion point for things like analytics, general purpose code spanning the whole application or third party services code. Using it you can avoid to have to override App.jsx component. How to use it # You can use it by overriding it via Component Shadowing by placing a custom src/customizations/components/theme/AppExtras/AppExtras.jsx .","title":"App component insertion point"},{"location":"recipes/appextras/#appextras-component","text":"The AppExtras component is a general use insertion point for things like analytics, general purpose code spanning the whole application or third party services code. Using it you can avoid to have to override App.jsx component.","title":"AppExtras component"},{"location":"recipes/appextras/#how-to-use-it","text":"You can use it by overriding it via Component Shadowing by placing a custom src/customizations/components/theme/AppExtras/AppExtras.jsx .","title":"How to use it"},{"location":"recipes/creating-project/","text":"Creating a new Volto project # For using Volto for a project (i.e. use Volto as a library), You should use the create-volto-app command. It's a boilerplate generator that will provide you with the basic files and folder structure to bootstrap a Volto site. Open a terminal and execute: $ npm -g i @plone/create-volto-app Warning It's not recommended to use yarn for installing create-volto-app , use npm instead. Tip Optionally, you can also use npx utility to install create-volto-app without having to install it globally. On the other hand, in order to do it, you have to install npx globally. The advantage is that you don't have to upgrade create-volto-app each time you want to use it, because npx does it for you: npx @plone/create-volto-app myvoltoapp Create a new Volto app using the recently added command, providing the name of the new app (folder) to be created. $ create-volto-app myvoltoapp Change the directory to myvoltoapp . $ cd myvoltoapp The project is ready to be started, create-volto-app already has run the dependencies installations for you. $ yarn start will start the development server, compiling and leaving the app ready at: http://localhost:3000","title":"Creating a project"},{"location":"recipes/creating-project/#creating-a-new-volto-project","text":"For using Volto for a project (i.e. use Volto as a library), You should use the create-volto-app command. It's a boilerplate generator that will provide you with the basic files and folder structure to bootstrap a Volto site. Open a terminal and execute: $ npm -g i @plone/create-volto-app Warning It's not recommended to use yarn for installing create-volto-app , use npm instead. Tip Optionally, you can also use npx utility to install create-volto-app without having to install it globally. On the other hand, in order to do it, you have to install npx globally. The advantage is that you don't have to upgrade create-volto-app each time you want to use it, because npx does it for you: npx @plone/create-volto-app myvoltoapp Create a new Volto app using the recently added command, providing the name of the new app (folder) to be created. $ create-volto-app myvoltoapp Change the directory to myvoltoapp . $ cd myvoltoapp The project is ready to be started, create-volto-app already has run the dependencies installations for you. $ yarn start will start the development server, compiling and leaving the app ready at: http://localhost:3000","title":"Creating a new Volto project"},{"location":"recipes/creating-views/","text":"Creating Volto Views # Full View # In this chapter we are going to create a new type of view for displaying contents in a folder. We will call this view full view . In Plone there is a view called All content with the view id full_view that we will reuse. We start by creating a file called: components/FullView/FullView.jsx . /** * Full view component. * @module components/theme/View/FullView */ import React from 'react' ; import PropTypes from 'prop-types' ; import { Link } from 'react-router-dom' ; import { Container , Image } from 'semantic-ui-react' ; import { FormattedMessage } from 'react-intl' ; /** * Full view component class. * @function FullView * @param {Object} content Content object. * @returns {string} Markup of the component. */ const FullView = ({ content }) => ( < Container className = \"view-wrapper\" > < article id = \"content\" > < header > < h1 className = \"documentFirstHeading\" >{ content . title }</ h1 > { content . description && ( < p className = \"documentDescription\" >{ content . description }</ p > )} </ header > < section id = \"content-core\" > { content . items . map ( item => ( < article key = { item . url }> < h2 > < Link to = { item . url } title = { item [ '@type' ]}> { item . title } </ Link > </ h2 > { item . image && ( < Image clearing floated = \"right\" alt = { item . image_caption ? item . image_caption : item . title } src = { item . image . scales . thumb . download } /> )} { item . description && < p >{ item . description }</ p >} { item . text && item . text . data && ( < p dangerouslySetInnerHTML = {{ __html : item . text . data }} /> )} </ article > ))} </ section > </ article > </ Container > ); /** * Property types. * @property {Object} propTypes Property types. * @static */ FullView . propTypes = { /** * Content of the object */ content : PropTypes . shape ({ /** * Title of the object */ title : PropTypes . string , /** * Description of the object */ description : PropTypes . string , /** * Child items of the object */ items : PropTypes . arrayOf ( PropTypes . shape ({ /** * Title of the item */ title : PropTypes . string , /** * Description of the item */ description : PropTypes . string , /** * Url of the item */ url : PropTypes . string , /** * Image of the item */ image : PropTypes . object , /** * Image caption of the item */ image_caption : PropTypes . string , /** * Type of the item */ '@type' : PropTypes . string , }), ), }). isRequired , }; export default FullView ; Next we will add the view to the app components. We can do this by adding the following lines to components/index.js . import FullView from './FullView/FullView' ; export { FullView }; Registering The View # To register the view we will edit the config.js file. The views configuration options contains all the views. This object contains an object called layoutViews which registers all the layout views. We will add the full_view to this object. import { FullView } from './components' ; export const views = { ... defaultViews , layoutViews : { ... defaultViews . layoutViews , full_view : FullView , }, }; Registering a new view called Album View # Create the Album View that shows the images in a grid. You can use the Card class from semantic-ui , components/AlbumView/AlbumView.jsx : /** * Album view component. * @module components/theme/View/AlbumView */ import React from 'react' ; import PropTypes from 'prop-types' ; import { Link } from 'react-router-dom' ; import { Card , Container , Image } from 'semantic-ui-react' ; import { FormattedMessage } from 'react-intl' ; /** * Album view component class. * @function AlbumView * @param {Object} content Content object. * @returns {string} Markup of the component. */ const AlbumView = ({ content }) => ( < Container className = \"view-wrapper\" > < article id = \"content\" > < header > < h1 className = \"documentFirstHeading\" >{ content . title }</ h1 > { content . description && ( < p className = \"documentDescription\" >{ content . description }</ p > )} </ header > < section id = \"content-core\" > < Card . Group > { content . items . map ( item => ( < Card key = { item . url }> { item . image && ( < Image alt = { item . image_caption ? item . image_caption : item . title } src = { item . image . scales . thumb . download } /> )} < Card . Content > < Card . Header > < Link to = { item . url } title = { item [ '@type' ]}> { item . title } </ Link > </ Card . Header > </ Card . Content > </ Card > ))} </ Card . Group > </ section > </ article > </ Container > ); /** * Property types. * @property {Object} propTypes Property types. * @static */ AlbumView . propTypes = { /** * Content of the object */ content : PropTypes . shape ({ /** * Title of the object */ title : PropTypes . string , /** * Description of the object */ description : PropTypes . string , /** * Child items of the object */ items : PropTypes . arrayOf ( PropTypes . shape ({ /** * Title of the item */ title : PropTypes . string , /** * Description of the item */ description : PropTypes . string , /** * Url of the item */ url : PropTypes . string , /** * Image of the item */ image : PropTypes . object , /** * Image caption of the item */ image_caption : PropTypes . string , /** * Type of the item */ '@type' : PropTypes . string , }), ), }). isRequired , }; export default AlbumView ; Then in components/index.js : /** * Add your components here. * @module components * @example * import Footer from './Footer/Footer'; * * export { * Footer, * }; */ import AlbumView from './AlbumView/AlbumView' ; import FullView from './FullView/FullView' ; export { AlbumView , FullView }; And in config.js : /** * Add your config changes here. * @module config * @example * export const settings = { * ...defaultSettings, * port: 4300, * listBlockTypes: { * ...defaultSettings.listBlockTypes, * 'my-list-item', * } * } */ import { settings as defaultSettings , views as defaultViews , widgets as defaultWidgets , blocks as defaultBlocks , } from '@plone/volto/config' ; import { AlbumView , FullView } from './components' ; export const settings = { ... defaultSettings , }; export const views = { ... defaultViews , layoutViews : { ... defaultViews . layoutViews , album_view : AlbumView , full_view : FullView , }, }; export const widgets = { ... defaultWidgets , }; export const blocks = { ... defaultBlocks , }; export default SummaryView ;","title":"Creating new views"},{"location":"recipes/creating-views/#creating-volto-views","text":"","title":"Creating Volto Views"},{"location":"recipes/creating-views/#full-view","text":"In this chapter we are going to create a new type of view for displaying contents in a folder. We will call this view full view . In Plone there is a view called All content with the view id full_view that we will reuse. We start by creating a file called: components/FullView/FullView.jsx . /** * Full view component. * @module components/theme/View/FullView */ import React from 'react' ; import PropTypes from 'prop-types' ; import { Link } from 'react-router-dom' ; import { Container , Image } from 'semantic-ui-react' ; import { FormattedMessage } from 'react-intl' ; /** * Full view component class. * @function FullView * @param {Object} content Content object. * @returns {string} Markup of the component. */ const FullView = ({ content }) => ( < Container className = \"view-wrapper\" > < article id = \"content\" > < header > < h1 className = \"documentFirstHeading\" >{ content . title }</ h1 > { content . description && ( < p className = \"documentDescription\" >{ content . description }</ p > )} </ header > < section id = \"content-core\" > { content . items . map ( item => ( < article key = { item . url }> < h2 > < Link to = { item . url } title = { item [ '@type' ]}> { item . title } </ Link > </ h2 > { item . image && ( < Image clearing floated = \"right\" alt = { item . image_caption ? item . image_caption : item . title } src = { item . image . scales . thumb . download } /> )} { item . description && < p >{ item . description }</ p >} { item . text && item . text . data && ( < p dangerouslySetInnerHTML = {{ __html : item . text . data }} /> )} </ article > ))} </ section > </ article > </ Container > ); /** * Property types. * @property {Object} propTypes Property types. * @static */ FullView . propTypes = { /** * Content of the object */ content : PropTypes . shape ({ /** * Title of the object */ title : PropTypes . string , /** * Description of the object */ description : PropTypes . string , /** * Child items of the object */ items : PropTypes . arrayOf ( PropTypes . shape ({ /** * Title of the item */ title : PropTypes . string , /** * Description of the item */ description : PropTypes . string , /** * Url of the item */ url : PropTypes . string , /** * Image of the item */ image : PropTypes . object , /** * Image caption of the item */ image_caption : PropTypes . string , /** * Type of the item */ '@type' : PropTypes . string , }), ), }). isRequired , }; export default FullView ; Next we will add the view to the app components. We can do this by adding the following lines to components/index.js . import FullView from './FullView/FullView' ; export { FullView };","title":"Full View"},{"location":"recipes/creating-views/#registering-the-view","text":"To register the view we will edit the config.js file. The views configuration options contains all the views. This object contains an object called layoutViews which registers all the layout views. We will add the full_view to this object. import { FullView } from './components' ; export const views = { ... defaultViews , layoutViews : { ... defaultViews . layoutViews , full_view : FullView , }, };","title":"Registering The View"},{"location":"recipes/creating-views/#registering-a-new-view-called-album-view","text":"Create the Album View that shows the images in a grid. You can use the Card class from semantic-ui , components/AlbumView/AlbumView.jsx : /** * Album view component. * @module components/theme/View/AlbumView */ import React from 'react' ; import PropTypes from 'prop-types' ; import { Link } from 'react-router-dom' ; import { Card , Container , Image } from 'semantic-ui-react' ; import { FormattedMessage } from 'react-intl' ; /** * Album view component class. * @function AlbumView * @param {Object} content Content object. * @returns {string} Markup of the component. */ const AlbumView = ({ content }) => ( < Container className = \"view-wrapper\" > < article id = \"content\" > < header > < h1 className = \"documentFirstHeading\" >{ content . title }</ h1 > { content . description && ( < p className = \"documentDescription\" >{ content . description }</ p > )} </ header > < section id = \"content-core\" > < Card . Group > { content . items . map ( item => ( < Card key = { item . url }> { item . image && ( < Image alt = { item . image_caption ? item . image_caption : item . title } src = { item . image . scales . thumb . download } /> )} < Card . Content > < Card . Header > < Link to = { item . url } title = { item [ '@type' ]}> { item . title } </ Link > </ Card . Header > </ Card . Content > </ Card > ))} </ Card . Group > </ section > </ article > </ Container > ); /** * Property types. * @property {Object} propTypes Property types. * @static */ AlbumView . propTypes = { /** * Content of the object */ content : PropTypes . shape ({ /** * Title of the object */ title : PropTypes . string , /** * Description of the object */ description : PropTypes . string , /** * Child items of the object */ items : PropTypes . arrayOf ( PropTypes . shape ({ /** * Title of the item */ title : PropTypes . string , /** * Description of the item */ description : PropTypes . string , /** * Url of the item */ url : PropTypes . string , /** * Image of the item */ image : PropTypes . object , /** * Image caption of the item */ image_caption : PropTypes . string , /** * Type of the item */ '@type' : PropTypes . string , }), ), }). isRequired , }; export default AlbumView ; Then in components/index.js : /** * Add your components here. * @module components * @example * import Footer from './Footer/Footer'; * * export { * Footer, * }; */ import AlbumView from './AlbumView/AlbumView' ; import FullView from './FullView/FullView' ; export { AlbumView , FullView }; And in config.js : /** * Add your config changes here. * @module config * @example * export const settings = { * ...defaultSettings, * port: 4300, * listBlockTypes: { * ...defaultSettings.listBlockTypes, * 'my-list-item', * } * } */ import { settings as defaultSettings , views as defaultViews , widgets as defaultWidgets , blocks as defaultBlocks , } from '@plone/volto/config' ; import { AlbumView , FullView } from './components' ; export const settings = { ... defaultSettings , }; export const views = { ... defaultViews , layoutViews : { ... defaultViews . layoutViews , album_view : AlbumView , full_view : FullView , }, }; export const widgets = { ... defaultWidgets , }; export const blocks = { ... defaultBlocks , }; export default SummaryView ;","title":"Registering a new view called Album View"},{"location":"recipes/customizing-components/","text":"Customizing Components # You are able to customize the existing Volto components using a pattern called component shadowing using the customizations folder. You have to identify and locate the component that you want to customize, let's say the Logo component in Volto source code . Tip Those familiar with Plone's JBOT customizing add-on will recognize this pattern since it works the same way, except that here you have to create exactly the same folder structure hierarchy of the original component instead of using the dotted notation used in JBOT overrides. You can override any component that lives inside Volto's src folder and adapt it to your needs, without touching the original (source) counterparts. Components are named in a semantic and approachable way. In order to identify them, you can use several approaches the main one using React Developer Tools then you can inspect the app and find out the name of the component (the name of the tag), then search for it in the Volto source code. To override the component, use the same folder structure that the original component has in the Volto source code and place it inside the customizations folder. Customizing the Logo resource # So, for example, if we want to replace the Logo which is located in Volto at components/theme/Logo/Logo.svg , the folder structure needs to match the folder structure of Volto in the customizations folder. So the final path of the new overridden component will be: customizations/components/theme/Logo/Logo.svg . Change The Tags Component # When overriding components, we follow the same approach. We will copy over the original component from the Volto source code, then amend the imports (if any are required) to match the current folder structure. Point Volto source code using @plone/volto module instead of relative paths and other amendments required. Locate the Tags.jsx file and override this file so that there is a label in front of the tags with: Tags: . /** * Tags component. * @module components/theme/Tags/Tags */ import React from 'react' ; import { Link } from 'react-router-dom' ; import PropTypes from 'prop-types' ; import { Container } from 'semantic-ui-react' ; /** * Tags component class. * @function Tags * @param {array} tags Array of tags. * @returns {string} Markup of the component. */ const Tags = ({ tags }) => tags && tags . length > 0 ? ( < Container > Tags : { tags . map ( tag => ( < Link className = \"ui label\" to = { `/search?Subject= ${ tag } ` } key = { tag }> { tag } </ Link > ))} </ Container > ) : ( < span /> ); /** * Property types. * @property {Object} propTypes Property types. * @static */ Tags . propTypes = { tags : PropTypes . arrayOf ( PropTypes . string ), }; /** * Default properties. * @property {Object} defaultProps Default properties. * @static */ Tags . defaultProps = { tags : null , }; export default Tags ; The final path of the overrided component will be customizations/components/theme/Tags/Tags.jsx . Advanced customization scenarios # Once you've started developing your Volto project, you'll find that you want also to integrate other third-party Volto addons and pottentially customize files from those addons. You may even want to write an addon that customizes Volto or other addons, on its own. To customize an addon, you can follow the pattern described above, but place the addon customization files in a folder named after the addon, inside the src/customizations folder. So, for example, to customize the volto-venue/src/components/OSMMap/OSMMap.jsx file, you would create a src/customizations/volto-venue/components/OSMMap/OSMMap.jsx shadow file. If you start customizing addons, to keep a clean folder structure inside src/customizations , you can move the Volto customizations file in a src/customizations/volto subfolder Addons can also customize Volto and other addons using the same logic. The default customization path inside an addon is src/customizations , but the addon can specify its own customization path with the customizationsPaths key in package.json . The customizationPaths is a list that takes strings with paths relative to the package.json file. All these paths are looked up for customization files. Tip The customizationPaths key is also available in the project, not just the addons In case of conflicts where multiple addons customize the same file, the order of addon declaration matters: the last addon declared in the addons key in the project's package.json wins. Further more, the project's customizations are applied last, so they \"win\" in the conflict resolution.","title":"Customizing components"},{"location":"recipes/customizing-components/#customizing-components","text":"You are able to customize the existing Volto components using a pattern called component shadowing using the customizations folder. You have to identify and locate the component that you want to customize, let's say the Logo component in Volto source code . Tip Those familiar with Plone's JBOT customizing add-on will recognize this pattern since it works the same way, except that here you have to create exactly the same folder structure hierarchy of the original component instead of using the dotted notation used in JBOT overrides. You can override any component that lives inside Volto's src folder and adapt it to your needs, without touching the original (source) counterparts. Components are named in a semantic and approachable way. In order to identify them, you can use several approaches the main one using React Developer Tools then you can inspect the app and find out the name of the component (the name of the tag), then search for it in the Volto source code. To override the component, use the same folder structure that the original component has in the Volto source code and place it inside the customizations folder.","title":"Customizing Components"},{"location":"recipes/customizing-components/#customizing-the-logo-resource","text":"So, for example, if we want to replace the Logo which is located in Volto at components/theme/Logo/Logo.svg , the folder structure needs to match the folder structure of Volto in the customizations folder. So the final path of the new overridden component will be: customizations/components/theme/Logo/Logo.svg .","title":"Customizing the Logo resource"},{"location":"recipes/customizing-components/#change-the-tags-component","text":"When overriding components, we follow the same approach. We will copy over the original component from the Volto source code, then amend the imports (if any are required) to match the current folder structure. Point Volto source code using @plone/volto module instead of relative paths and other amendments required. Locate the Tags.jsx file and override this file so that there is a label in front of the tags with: Tags: . /** * Tags component. * @module components/theme/Tags/Tags */ import React from 'react' ; import { Link } from 'react-router-dom' ; import PropTypes from 'prop-types' ; import { Container } from 'semantic-ui-react' ; /** * Tags component class. * @function Tags * @param {array} tags Array of tags. * @returns {string} Markup of the component. */ const Tags = ({ tags }) => tags && tags . length > 0 ? ( < Container > Tags : { tags . map ( tag => ( < Link className = \"ui label\" to = { `/search?Subject= ${ tag } ` } key = { tag }> { tag } </ Link > ))} </ Container > ) : ( < span /> ); /** * Property types. * @property {Object} propTypes Property types. * @static */ Tags . propTypes = { tags : PropTypes . arrayOf ( PropTypes . string ), }; /** * Default properties. * @property {Object} defaultProps Default properties. * @static */ Tags . defaultProps = { tags : null , }; export default Tags ; The final path of the overrided component will be customizations/components/theme/Tags/Tags.jsx .","title":"Change The Tags Component"},{"location":"recipes/customizing-components/#advanced-customization-scenarios","text":"Once you've started developing your Volto project, you'll find that you want also to integrate other third-party Volto addons and pottentially customize files from those addons. You may even want to write an addon that customizes Volto or other addons, on its own. To customize an addon, you can follow the pattern described above, but place the addon customization files in a folder named after the addon, inside the src/customizations folder. So, for example, to customize the volto-venue/src/components/OSMMap/OSMMap.jsx file, you would create a src/customizations/volto-venue/components/OSMMap/OSMMap.jsx shadow file. If you start customizing addons, to keep a clean folder structure inside src/customizations , you can move the Volto customizations file in a src/customizations/volto subfolder Addons can also customize Volto and other addons using the same logic. The default customization path inside an addon is src/customizations , but the addon can specify its own customization path with the customizationsPaths key in package.json . The customizationPaths is a list that takes strings with paths relative to the package.json file. All these paths are looked up for customization files. Tip The customizationPaths key is also available in the project, not just the addons In case of conflicts where multiple addons customize the same file, the order of addon declaration matters: the last addon declared in the addons key in the project's package.json wins. Further more, the project's customizations are applied last, so they \"win\" in the conflict resolution.","title":"Advanced customization scenarios"},{"location":"recipes/customizing-views/","text":"Customizing Volto Views # Overriding existing views works exactly the same as components. Override the summary view so that the Read more... text is gone and is replaced by the rich text content. /** * Summary view component. * @module components/theme/View/SummaryView */ import React from 'react' ; import PropTypes from 'prop-types' ; import { Link } from 'react-router-dom' ; import { Container , Image } from 'semantic-ui-react' ; import { FormattedMessage } from 'react-intl' ; /** * Summary view component class. * @function SummaryView * @param {Object} content Content object. * @returns {string} Markup of the component. */ const SummaryView = ({ content }) => ( < Container className = \"view-wrapper\" > < article id = \"content\" > < header > < h1 className = \"documentFirstHeading\" >{ content . title }</ h1 > { content . description && ( < p className = \"documentDescription\" >{ content . description }</ p > )} </ header > < section id = \"content-core\" > { content . items . map ( item => ( < article key = { item . url }> < h2 > < Link to = { item . url } title = { item [ '@type' ]}> { item . title } </ Link > </ h2 > { item . image && ( < Image clearing floated = \"right\" alt = { item . image_caption ? item . image_caption : item . title } src = { item . image . scales . thumb . download } /> )} { item . description && < p >{ item . description }</ p >} { item . text && item . text . data && ( < p dangerouslySetInnerHTML = {{ __html : item . text . data }} /> )} </ article > ))} </ section > </ article > </ Container > ); /** * Property types. * @property {Object} propTypes Property types. * @static */ SummaryView . propTypes = { /** * Content of the object */ content : PropTypes . shape ({ /** * Title of the object */ title : PropTypes . string , /** * Description of the object */ description : PropTypes . string , /** * Child items of the object */ items : PropTypes . arrayOf ( PropTypes . shape ({ /** * Title of the item */ title : PropTypes . string , /** * Description of the item */ description : PropTypes . string , /** * Url of the item */ url : PropTypes . string , /** * Image of the item */ image : PropTypes . object , /** * Image caption of the item */ image_caption : PropTypes . string , /** * Type of the item */ '@type' : PropTypes . string , }), ), }). isRequired , }; export default SummaryView ;","title":"Customizing views"},{"location":"recipes/customizing-views/#customizing-volto-views","text":"Overriding existing views works exactly the same as components. Override the summary view so that the Read more... text is gone and is replaced by the rich text content. /** * Summary view component. * @module components/theme/View/SummaryView */ import React from 'react' ; import PropTypes from 'prop-types' ; import { Link } from 'react-router-dom' ; import { Container , Image } from 'semantic-ui-react' ; import { FormattedMessage } from 'react-intl' ; /** * Summary view component class. * @function SummaryView * @param {Object} content Content object. * @returns {string} Markup of the component. */ const SummaryView = ({ content }) => ( < Container className = \"view-wrapper\" > < article id = \"content\" > < header > < h1 className = \"documentFirstHeading\" >{ content . title }</ h1 > { content . description && ( < p className = \"documentDescription\" >{ content . description }</ p > )} </ header > < section id = \"content-core\" > { content . items . map ( item => ( < article key = { item . url }> < h2 > < Link to = { item . url } title = { item [ '@type' ]}> { item . title } </ Link > </ h2 > { item . image && ( < Image clearing floated = \"right\" alt = { item . image_caption ? item . image_caption : item . title } src = { item . image . scales . thumb . download } /> )} { item . description && < p >{ item . description }</ p >} { item . text && item . text . data && ( < p dangerouslySetInnerHTML = {{ __html : item . text . data }} /> )} </ article > ))} </ section > </ article > </ Container > ); /** * Property types. * @property {Object} propTypes Property types. * @static */ SummaryView . propTypes = { /** * Content of the object */ content : PropTypes . shape ({ /** * Title of the object */ title : PropTypes . string , /** * Description of the object */ description : PropTypes . string , /** * Child items of the object */ items : PropTypes . arrayOf ( PropTypes . shape ({ /** * Title of the item */ title : PropTypes . string , /** * Description of the item */ description : PropTypes . string , /** * Url of the item */ url : PropTypes . string , /** * Image of the item */ image : PropTypes . object , /** * Image caption of the item */ image_caption : PropTypes . string , /** * Type of the item */ '@type' : PropTypes . string , }), ), }). isRequired , }; export default SummaryView ;","title":"Customizing Volto Views"},{"location":"recipes/express/","text":"Custom Express middleware # Volto uses the popular Express server for its Server-Side Rendering implementation and static resource serving. In some cases it is useful to extend this server with new functionality. For example, Volto includes a middleware that proxies the backend and that can be used during development. Other use cases might include a CORS proxy server, a proxy to protect a database such as ElasticSearch or MongoDB, etc. To add new middleware, use the settings.expressMiddleware configuration key. This is a list that takes Express middleware functions. For example: import { settings as defaultSettings , } from '@plone/volto/config' ; const settings = { ... defaultSettings }; if ( __SERVER__ ) { const express = require ( 'express' ); const middleware = express . Router (); middleware . all ( '/test-middleware' , function ( req , res , next ) { res . send ( 'Hello world' ); }); middleware . id = 'test-middleware' settings . expressMiddleware = [ ... defaultSettings . expressMiddleware , middleware , ] ; } Now the test-middleware page can be visited and it will return the simple string and not the usual Volto pages. Notice the use of the __SERVER__ condition. Because the code in a Volto project's config.js gets executed by both the server and the client (browser), the server-side libraries need to \"excluded\" with conditions. See ExpressJS website for more documentation. Note Addon authors should add the id property to the middleware so that it can be identified and manipulated in Volto projects configuration.","title":"Express middleware"},{"location":"recipes/express/#custom-express-middleware","text":"Volto uses the popular Express server for its Server-Side Rendering implementation and static resource serving. In some cases it is useful to extend this server with new functionality. For example, Volto includes a middleware that proxies the backend and that can be used during development. Other use cases might include a CORS proxy server, a proxy to protect a database such as ElasticSearch or MongoDB, etc. To add new middleware, use the settings.expressMiddleware configuration key. This is a list that takes Express middleware functions. For example: import { settings as defaultSettings , } from '@plone/volto/config' ; const settings = { ... defaultSettings }; if ( __SERVER__ ) { const express = require ( 'express' ); const middleware = express . Router (); middleware . all ( '/test-middleware' , function ( req , res , next ) { res . send ( 'Hello world' ); }); middleware . id = 'test-middleware' settings . expressMiddleware = [ ... defaultSettings . expressMiddleware , middleware , ] ; } Now the test-middleware page can be visited and it will return the simple string and not the usual Volto pages. Notice the use of the __SERVER__ condition. Because the code in a Volto project's config.js gets executed by both the server and the client (browser), the server-side libraries need to \"excluded\" with conditions. See ExpressJS website for more documentation. Note Addon authors should add the id property to the middleware so that it can be identified and manipulated in Volto projects configuration.","title":"Custom Express middleware"},{"location":"recipes/fetch-data/","text":"Fetch data with Redux # Warning Please contribute this section!","title":"Fetch data"},{"location":"recipes/fetch-data/#fetch-data-with-redux","text":"Warning Please contribute this section!","title":"Fetch data with Redux"},{"location":"recipes/folder-structure/","text":"Folder structure # Volto is based on React, Redux, and React-Router. All of the code is located in the src folder. The following convention for locating resources is used. Actions # actions contains all the redux actions for fetching all backend data like content, users and external resources that are pulled into our app in general. Components # components contains all the views. This includes views for the management interface and the theme. Config # In this folder all configuration is stored. All configuration can be overridden in your theme package. Constants # The constants contain all constants including the action types. Helpers # helpers contains helper methods like for example url helpers. Reducers # All the reducers are located here. Theme # The theme folder lives in the root of the Volto boilerplate and by default uses the Pastanaga Theme look and feel. Inside you can find the theme.config file that is used to set the theme general settings. The site customizations also should be located inside this folder following SemanticUI folder naming . assets collections elements globals modules views Locales # The locales folder contains all the artifacts relating to the translations. For more details how to translate individual strings, please refer to the internationalization section .","title":"Folder structure"},{"location":"recipes/folder-structure/#folder-structure","text":"Volto is based on React, Redux, and React-Router. All of the code is located in the src folder. The following convention for locating resources is used.","title":"Folder structure"},{"location":"recipes/folder-structure/#actions","text":"actions contains all the redux actions for fetching all backend data like content, users and external resources that are pulled into our app in general.","title":"Actions"},{"location":"recipes/folder-structure/#components","text":"components contains all the views. This includes views for the management interface and the theme.","title":"Components"},{"location":"recipes/folder-structure/#config","text":"In this folder all configuration is stored. All configuration can be overridden in your theme package.","title":"Config"},{"location":"recipes/folder-structure/#constants","text":"The constants contain all constants including the action types.","title":"Constants"},{"location":"recipes/folder-structure/#helpers","text":"helpers contains helper methods like for example url helpers.","title":"Helpers"},{"location":"recipes/folder-structure/#reducers","text":"All the reducers are located here.","title":"Reducers"},{"location":"recipes/folder-structure/#theme","text":"The theme folder lives in the root of the Volto boilerplate and by default uses the Pastanaga Theme look and feel. Inside you can find the theme.config file that is used to set the theme general settings. The site customizations also should be located inside this folder following SemanticUI folder naming . assets collections elements globals modules views","title":"Theme"},{"location":"recipes/folder-structure/#locales","text":"The locales folder contains all the artifacts relating to the translations. For more details how to translate individual strings, please refer to the internationalization section .","title":"Locales"},{"location":"recipes/i18n/","text":"Internationalization # Internationalization (i18n) is the process of creating user interfaces which are suitable for different languages and cultural contexts. Volto uses the library react-intl to provide translations for any potential language. Anything you can read in the official documentation of react-intl also applies for Volto. However this section teaches you about the most common use cases relating to i18n you probably will have when developing your own Add-on or contributing to the Volto core itself. Broad overview # The workflow for creating new translatable texts is as follows: Create translatable i18n strings in your code Extract all i18n strings from your code with a script and create artifacts like .po and .pot files Use your favorite editor to translate all i18n strings (i.e. edit the .po files) Re-run the script, which then moves the translations from the .po files into for Volto usable .json files This way of organizing translations relies on gettext , a proven and established system with great tool support. All translation files are located under the directory locales . This might look like this: $ tree locales/ locales/ \u251c\u2500\u2500 de \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 de.json \u251c\u2500\u2500 en \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 en.json \u251c\u2500\u2500 es \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 es.json \u251c\u2500\u2500 it \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 it.json \u251c\u2500\u2500 ja \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 ja.json \u251c\u2500\u2500 nl \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 nl.json \u2514\u2500\u2500 volto.pot 12 directories, 13 files The file volto.pot holds all extracted i18n strings and acts as master template for all the *.po files. The translation for each language is stored within a dedicated sub-directory (like en for English, it for Italian, etc.) and are stored as *.po file and separately stored directly under locales as *.json file. Creating i18n Strings # Translating Text Within HTML Elements # react-intl can identify translatable texts with the FormattedMessage components. As the name of this component suggests, it is also possible to format your messages as your liking. This is an example of how you can write a text with contents Hello World , which can be identified via hello_world : import { FormattedMessage } from 'react-intl'; function HelloWorld(props) { return ( <div> <FormattedMessage id=\"hello_world\" defaultMessage=\"Hello World\" /> </div> ); } The identifier hello_world is then commonly used between all the translations. There are also more features available such as using placeholders. See the docs for all features in the FormattedMessage component . Translating Attributes # As FormatMessage is only suitable for creating text within HTML elements, it cannot be used for translating individual attributes. But with the method formatMessage there exists another way to translate primitive strings. This approach can be best explained with an example: Assume you have a component called TeaserImage which contains an image that has for accessibility reasons the alt attribute. To translate the alt attribute, you have to do the following steps: Import the following necessary methods: import { defineMessages, injectIntl, intlShape } from 'react-intl'; Define a message (or more) via defineMessages : const messages = defineMessages({ teaserAltText: { id: 'teaser_alt_text', defaultMessage: 'Teaser Alt Text', }, }); As the method formatMessage in our component class/function is needed, there is a special propery intl , that needs to be injected with either the following ways: // When using a pure function: export default injectIntl(TeaserImage); // OR when using a component: @injectIntl class TeaserImage extends Component { ... } Since you now have another prop available, it has to be to properly defined in the propTypes: TeaserImage.propTypes = { intl: intlShape.isRequired, ... }; As last step, the method can be used like this: <img src=\"...\" alt={intl.formatMessage(messages.teaserAltText)}> Extracting i18n Strings # Volto provides an i18n extraction script to get all translatable strings from your application. This script can be invoked by this command: $ yarn i18n This will generate the following output: Extracting messages from source files... Synchronizing messages to pot file... Synchronizing messages to po files... Generating the json files... done! As the output suggests it will first extract all messages from the source files into .json files. Then it will synchronize the extracted messages with the .pot master template and with all the .po files found in the project. This script will combine the messages located in Volto itself and the current project, and combine them into the .json files. Contributing translations for a unsupported language # The Volto project welcomes all speakers from the world to include any language, which is not supported yet. You can contribute to translate Volto into severals languages at Transifex.net . When you done your translation resource at Transifex.net, you need to add the locales files into Volto project, for that you need use transifex-client tool and install it . Update language from Transifex # To get translate the latest translation changes, you have to do the following steps: You can pull the latest changes for a specific language, for example 'de' from Transifex.net for Volto project , by this command: $ tx pull -f -l de This will generate the following output: tx INFO: Pulling translations for resource plone5.volto-pot ( source: locales/volto.pot ) tx INFO: -> de: locales/de/LC_MESSAGES/volto.po tx INFO: Done. Also can pull the latest changes for all languages available at from Transifex.net for Volto project , by this command: $ tx pull -f --all You need updated the json file for the language updated from Transifex.net for Volto project , by this command: $ yarn i18n This command generate again the locales/de.json file updated, it is needed for Volto app. Please, update the CHANGELOG.md file, make commits and push the changes via pull request at the repository. Tip: For more information about each command, use tx <command> --help . As an example, to learn more about the tx pull command, run tx pull --help . Add new language from Transifex # You should check what languages are available in Transifex.net to translate for the Volto project . If the language to be translated does not exist, please request it . You can pull the new language for example Portuguese (Brazil) aka 'pt_BR' from Transifex.net for Volto project , by this command: $ tx pull -f -l pt_BR You new to modify the src/server.jsx file and add in the 'import section' as the follow: import ptBrLocale from '~/../locales/pt_BR.json'; Also you need define the new locale into 'locales const' as the follow: pt: ptBrLocale, You new to modify the src/constants/Languages.js file and add a new line at 'module.exports' section as the follow: pt_BR: 'Portugu\u00eas (Brasil)', You need create the json file for the language created from Transifex.net for Volto project , by this command: $ yarn i18n This command generate the locales/pt_BR.json file, it is needed for Volto app. Please, update the CHANGELOG.md file, make commits and push the changes via pull request at the repository.","title":"Internationalization"},{"location":"recipes/i18n/#internationalization","text":"Internationalization (i18n) is the process of creating user interfaces which are suitable for different languages and cultural contexts. Volto uses the library react-intl to provide translations for any potential language. Anything you can read in the official documentation of react-intl also applies for Volto. However this section teaches you about the most common use cases relating to i18n you probably will have when developing your own Add-on or contributing to the Volto core itself.","title":"Internationalization"},{"location":"recipes/i18n/#broad-overview","text":"The workflow for creating new translatable texts is as follows: Create translatable i18n strings in your code Extract all i18n strings from your code with a script and create artifacts like .po and .pot files Use your favorite editor to translate all i18n strings (i.e. edit the .po files) Re-run the script, which then moves the translations from the .po files into for Volto usable .json files This way of organizing translations relies on gettext , a proven and established system with great tool support. All translation files are located under the directory locales . This might look like this: $ tree locales/ locales/ \u251c\u2500\u2500 de \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 de.json \u251c\u2500\u2500 en \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 en.json \u251c\u2500\u2500 es \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 es.json \u251c\u2500\u2500 it \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 it.json \u251c\u2500\u2500 ja \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 ja.json \u251c\u2500\u2500 nl \u2502 \u2514\u2500\u2500 LC_MESSAGES \u2502 \u2514\u2500\u2500 volto.po \u251c\u2500\u2500 nl.json \u2514\u2500\u2500 volto.pot 12 directories, 13 files The file volto.pot holds all extracted i18n strings and acts as master template for all the *.po files. The translation for each language is stored within a dedicated sub-directory (like en for English, it for Italian, etc.) and are stored as *.po file and separately stored directly under locales as *.json file.","title":"Broad overview"},{"location":"recipes/i18n/#creating-i18n-strings","text":"","title":"Creating i18n Strings"},{"location":"recipes/i18n/#translating-text-within-html-elements","text":"react-intl can identify translatable texts with the FormattedMessage components. As the name of this component suggests, it is also possible to format your messages as your liking. This is an example of how you can write a text with contents Hello World , which can be identified via hello_world : import { FormattedMessage } from 'react-intl'; function HelloWorld(props) { return ( <div> <FormattedMessage id=\"hello_world\" defaultMessage=\"Hello World\" /> </div> ); } The identifier hello_world is then commonly used between all the translations. There are also more features available such as using placeholders. See the docs for all features in the FormattedMessage component .","title":"Translating Text Within HTML Elements"},{"location":"recipes/i18n/#translating-attributes","text":"As FormatMessage is only suitable for creating text within HTML elements, it cannot be used for translating individual attributes. But with the method formatMessage there exists another way to translate primitive strings. This approach can be best explained with an example: Assume you have a component called TeaserImage which contains an image that has for accessibility reasons the alt attribute. To translate the alt attribute, you have to do the following steps: Import the following necessary methods: import { defineMessages, injectIntl, intlShape } from 'react-intl'; Define a message (or more) via defineMessages : const messages = defineMessages({ teaserAltText: { id: 'teaser_alt_text', defaultMessage: 'Teaser Alt Text', }, }); As the method formatMessage in our component class/function is needed, there is a special propery intl , that needs to be injected with either the following ways: // When using a pure function: export default injectIntl(TeaserImage); // OR when using a component: @injectIntl class TeaserImage extends Component { ... } Since you now have another prop available, it has to be to properly defined in the propTypes: TeaserImage.propTypes = { intl: intlShape.isRequired, ... }; As last step, the method can be used like this: <img src=\"...\" alt={intl.formatMessage(messages.teaserAltText)}>","title":"Translating Attributes"},{"location":"recipes/i18n/#extracting-i18n-strings","text":"Volto provides an i18n extraction script to get all translatable strings from your application. This script can be invoked by this command: $ yarn i18n This will generate the following output: Extracting messages from source files... Synchronizing messages to pot file... Synchronizing messages to po files... Generating the json files... done! As the output suggests it will first extract all messages from the source files into .json files. Then it will synchronize the extracted messages with the .pot master template and with all the .po files found in the project. This script will combine the messages located in Volto itself and the current project, and combine them into the .json files.","title":"Extracting i18n Strings"},{"location":"recipes/i18n/#contributing-translations-for-a-unsupported-language","text":"The Volto project welcomes all speakers from the world to include any language, which is not supported yet. You can contribute to translate Volto into severals languages at Transifex.net . When you done your translation resource at Transifex.net, you need to add the locales files into Volto project, for that you need use transifex-client tool and install it .","title":"Contributing translations for a unsupported language"},{"location":"recipes/i18n/#update-language-from-transifex","text":"To get translate the latest translation changes, you have to do the following steps: You can pull the latest changes for a specific language, for example 'de' from Transifex.net for Volto project , by this command: $ tx pull -f -l de This will generate the following output: tx INFO: Pulling translations for resource plone5.volto-pot ( source: locales/volto.pot ) tx INFO: -> de: locales/de/LC_MESSAGES/volto.po tx INFO: Done. Also can pull the latest changes for all languages available at from Transifex.net for Volto project , by this command: $ tx pull -f --all You need updated the json file for the language updated from Transifex.net for Volto project , by this command: $ yarn i18n This command generate again the locales/de.json file updated, it is needed for Volto app. Please, update the CHANGELOG.md file, make commits and push the changes via pull request at the repository. Tip: For more information about each command, use tx <command> --help . As an example, to learn more about the tx pull command, run tx pull --help .","title":"Update language from Transifex"},{"location":"recipes/i18n/#add-new-language-from-transifex","text":"You should check what languages are available in Transifex.net to translate for the Volto project . If the language to be translated does not exist, please request it . You can pull the new language for example Portuguese (Brazil) aka 'pt_BR' from Transifex.net for Volto project , by this command: $ tx pull -f -l pt_BR You new to modify the src/server.jsx file and add in the 'import section' as the follow: import ptBrLocale from '~/../locales/pt_BR.json'; Also you need define the new locale into 'locales const' as the follow: pt: ptBrLocale, You new to modify the src/constants/Languages.js file and add a new line at 'module.exports' section as the follow: pt_BR: 'Portugu\u00eas (Brasil)', You need create the json file for the language created from Transifex.net for Volto project , by this command: $ yarn i18n This command generate the locales/pt_BR.json file, it is needed for Volto app. Please, update the CHANGELOG.md file, make commits and push the changes via pull request at the repository.","title":"Add new language from Transifex"},{"location":"recipes/lazyload/","text":"Lazy loading # Since Volto 5.0.0 you are able to do splitting and lazy loading safely any app component using @loadable/component library. You can also benefit from it in your own project by using it. Note Webpack 4 is already lazy load enabled, using import() but @loadable/component makes the process safe since Volto is using Server Side Rendering. The React community is working actively in the React async mode popularly known as Suspense. Suspense will be SSR safe but in the meanwhile it's not ready, @loadable/component is the community accepted replacement. Lazy load a component # export const DatetimeWidget = loadable (() => import ( '@plone/volto/components/manage/Widgets/DatetimeWidget' ), ); Then use DatetimeWidget as you'll do normally using a standard import statement. Tip You can find the complete @loadable/component documentation here: https://loadable-components.com Code splitting bundle analyzer # You can check the code splitting state by using the included bundle analyzer: $ yarn analyze A browser will open with the bundle inspector.","title":"Lazy loading and code splitting"},{"location":"recipes/lazyload/#lazy-loading","text":"Since Volto 5.0.0 you are able to do splitting and lazy loading safely any app component using @loadable/component library. You can also benefit from it in your own project by using it. Note Webpack 4 is already lazy load enabled, using import() but @loadable/component makes the process safe since Volto is using Server Side Rendering. The React community is working actively in the React async mode popularly known as Suspense. Suspense will be SSR safe but in the meanwhile it's not ready, @loadable/component is the community accepted replacement.","title":"Lazy loading"},{"location":"recipes/lazyload/#lazy-load-a-component","text":"export const DatetimeWidget = loadable (() => import ( '@plone/volto/components/manage/Widgets/DatetimeWidget' ), ); Then use DatetimeWidget as you'll do normally using a standard import statement. Tip You can find the complete @loadable/component documentation here: https://loadable-components.com","title":"Lazy load a component"},{"location":"recipes/lazyload/#code-splitting-bundle-analyzer","text":"You can check the code splitting state by using the included bundle analyzer: $ yarn analyze A browser will open with the bundle inspector.","title":"Code splitting bundle analyzer"},{"location":"recipes/overridei18n/","text":"Overriding i18n messages # If you want to override an existing translation, you should declare the original message again somewhere else in your project, e.g in src/config.js , like this: import { defineMessages } from 'react-intl' ; defineMessages ({ back : { id : 'Back' , defaultMessage : 'Back' , }, } Then run yarn i18n and you'll find the translation ready to override in your locales directory, e.g locales/de/LC_MESSAGES/volto.po . #: src/config msgid \"Back\" msgstr \"My overriden translation\" After setting the override, then run yarn i18n again, to create the de.json translation files. Restart Volto to see the changes applied. Note Shadowed components do NOT override translations, since 99% of the time, you don't want them to do that, so the customizations folder is excluded from the i18n build.","title":"Overriding i18n messages"},{"location":"recipes/overridei18n/#overriding-i18n-messages","text":"If you want to override an existing translation, you should declare the original message again somewhere else in your project, e.g in src/config.js , like this: import { defineMessages } from 'react-intl' ; defineMessages ({ back : { id : 'Back' , defaultMessage : 'Back' , }, } Then run yarn i18n and you'll find the translation ready to override in your locales directory, e.g locales/de/LC_MESSAGES/volto.po . #: src/config msgid \"Back\" msgstr \"My overriden translation\" After setting the override, then run yarn i18n again, to create the de.json translation files. Restart Volto to see the changes applied. Note Shadowed components do NOT override translations, since 99% of the time, you don't want them to do that, so the customizations folder is excluded from the i18n build.","title":"Overriding i18n messages"},{"location":"recipes/widget/","text":"Write a new widget # Warning Please contribute this section!","title":"Create a widget"},{"location":"recipes/widget/#write-a-new-widget","text":"Warning Please contribute this section!","title":"Write a new widget"},{"location":"theming/about-semantic/","text":"About Semantic UI # Volto uses Semantic UI and React Semantic UI (via semantic-ui-less ) as development framework. It helps you to create websites with responsive layouts using human-friendly HTML. Semantic UI treats words and classes as exchangeable concepts. Classes use syntax from natural languages like noun/modifier relationships, word order, and plurality to link concepts intuitively. One of its main features is theming. Components in Semantic UI are designed to help developers adhere to progressive truthfulness in their development. Instead of having to create components from a blank canvas, developers using Semantic UI only need to specify how their components should differ from the default theme using CSS variables and other CSS overrides (if required). It sports a sophisticated theming engine built with LESS CSS preprocessor that allows you to have different layers of defaults/CSS variables modifiers/CSS overrides in place, inheriting one from the parent in a sensible manner:","title":"About Semantic UI"},{"location":"theming/about-semantic/#about-semantic-ui","text":"Volto uses Semantic UI and React Semantic UI (via semantic-ui-less ) as development framework. It helps you to create websites with responsive layouts using human-friendly HTML. Semantic UI treats words and classes as exchangeable concepts. Classes use syntax from natural languages like noun/modifier relationships, word order, and plurality to link concepts intuitively. One of its main features is theming. Components in Semantic UI are designed to help developers adhere to progressive truthfulness in their development. Instead of having to create components from a blank canvas, developers using Semantic UI only need to specify how their components should differ from the default theme using CSS variables and other CSS overrides (if required). It sports a sophisticated theming engine built with LESS CSS preprocessor that allows you to have different layers of defaults/CSS variables modifiers/CSS overrides in place, inheriting one from the parent in a sensible manner:","title":"About Semantic UI"},{"location":"theming/custom-styling/","text":"Custom Styling # Semantic UI # For styling our website in Volto we use Semantic UI. It uses LESS as the underlaying technology. By default Volto uses the Pastanaga theme but any theme can be used. A theme has the following folder structure: assets collections elements globals modules views Variables and overrides files # The assets folder contains all the images and fonts. The other folders contain LESS files. Those less files are separate for each UI component. For example we have separate files for buttons. Each UI component has 2 files: a .variables file and an .overrides file. The .variables file contains all the predefined variables which you can override in your theme. If you want to do more specific customizations you can use the .overrides file to write your own LESS. Tip You can find the default definitions for all the available variables in the default theme components (the site component in the example) in two ways, by using the source code: node_modules/semantic-ui-less/themes/default/globals/site.variables or by checking it out on Github: https://github.com/Semantic-Org/Semantic-UI-LESS/blob/master/themes/default/globals/site.variables Tip Similarly, you can take a look at the default styling on the default definitions, by using the source code: node_modules/semantic-ui-less/definitions/globals/site.less or by checking it out on Github: https://github.com/Semantic-Org/Semantic-UI-LESS/blob/master/definitions/globals/site.less In the globals folder we have the site.variables and site.overrides files which contain the site wide styling. If you want to customize something in the site component, you should create the globals folder and place inside one (or both) files (including the matching folder structure) in your theme folder. Pastanaga UI Theme # Volto implements Pastanaga UI theme, a new theme for Content Management Systems created and designed by Albert Casado . For more info: https://pastanaga.io https://github.com/plone/pastanaga https://2017.ploneconf.org/talks/pastanaga-ui-resistance-is-futile Volto look and feel is a Semantic UI theme that implements Pastanaga UI, called pastanaga and can be found in the Volto theme/themes/pastanaga directory. Tip You can find it in the source code: node_modules/@plone/volto/theme/themes/pastanaga or on Github: https://github.com/plone/volto/tree/master/theme/themes/pastanaga Pastanaga Theme is an example on how to customize the default Semantic UI look and feel. Examples: Changing Base Font # We start by creating the file theme/globals/site.variables . In this file we can override any value. We do not need to copy the whole file. We can add variables we would like to change. When we want to change the base font, we add the following: @fontName : 'Comic Sans MS' ; Make sure you have the 'Comic Sans MS' font installed. This is the 'ttf-mscorefonts-installer' package for the Debian linux distribution. If you create a new file, the watcher won't be aware of it, you must restart the yarn start Volto process again. You can also point it to any Google Web Font name like: @fontName : 'Montserrat' ; Changing The Breadcrumbs # Change the breadcrumbs so that the divider is pink in theme/collections/breadcrumb.variables : @dividerColor : @pink ; Using Overrides # For features which are not supported in Semantic UI through the variables, we can use the overrides files. Update the breadcrumbs so that the links are underlined, then in theme/collections/breadcrumb.overrides : . ui . breadcrumb a { text-decoration : underline ; }","title":"Custom styling"},{"location":"theming/custom-styling/#custom-styling","text":"","title":"Custom Styling"},{"location":"theming/custom-styling/#semantic-ui","text":"For styling our website in Volto we use Semantic UI. It uses LESS as the underlaying technology. By default Volto uses the Pastanaga theme but any theme can be used. A theme has the following folder structure: assets collections elements globals modules views","title":"Semantic UI"},{"location":"theming/custom-styling/#variables-and-overrides-files","text":"The assets folder contains all the images and fonts. The other folders contain LESS files. Those less files are separate for each UI component. For example we have separate files for buttons. Each UI component has 2 files: a .variables file and an .overrides file. The .variables file contains all the predefined variables which you can override in your theme. If you want to do more specific customizations you can use the .overrides file to write your own LESS. Tip You can find the default definitions for all the available variables in the default theme components (the site component in the example) in two ways, by using the source code: node_modules/semantic-ui-less/themes/default/globals/site.variables or by checking it out on Github: https://github.com/Semantic-Org/Semantic-UI-LESS/blob/master/themes/default/globals/site.variables Tip Similarly, you can take a look at the default styling on the default definitions, by using the source code: node_modules/semantic-ui-less/definitions/globals/site.less or by checking it out on Github: https://github.com/Semantic-Org/Semantic-UI-LESS/blob/master/definitions/globals/site.less In the globals folder we have the site.variables and site.overrides files which contain the site wide styling. If you want to customize something in the site component, you should create the globals folder and place inside one (or both) files (including the matching folder structure) in your theme folder.","title":"Variables and overrides files"},{"location":"theming/custom-styling/#pastanaga-ui-theme","text":"Volto implements Pastanaga UI theme, a new theme for Content Management Systems created and designed by Albert Casado . For more info: https://pastanaga.io https://github.com/plone/pastanaga https://2017.ploneconf.org/talks/pastanaga-ui-resistance-is-futile Volto look and feel is a Semantic UI theme that implements Pastanaga UI, called pastanaga and can be found in the Volto theme/themes/pastanaga directory. Tip You can find it in the source code: node_modules/@plone/volto/theme/themes/pastanaga or on Github: https://github.com/plone/volto/tree/master/theme/themes/pastanaga Pastanaga Theme is an example on how to customize the default Semantic UI look and feel.","title":"Pastanaga UI Theme"},{"location":"theming/custom-styling/#examples-changing-base-font","text":"We start by creating the file theme/globals/site.variables . In this file we can override any value. We do not need to copy the whole file. We can add variables we would like to change. When we want to change the base font, we add the following: @fontName : 'Comic Sans MS' ; Make sure you have the 'Comic Sans MS' font installed. This is the 'ttf-mscorefonts-installer' package for the Debian linux distribution. If you create a new file, the watcher won't be aware of it, you must restart the yarn start Volto process again. You can also point it to any Google Web Font name like: @fontName : 'Montserrat' ;","title":"Examples: Changing Base Font"},{"location":"theming/custom-styling/#changing-the-breadcrumbs","text":"Change the breadcrumbs so that the divider is pink in theme/collections/breadcrumb.variables : @dividerColor : @pink ;","title":"Changing The Breadcrumbs"},{"location":"theming/custom-styling/#using-overrides","text":"For features which are not supported in Semantic UI through the variables, we can use the overrides files. Update the breadcrumbs so that the links are underlined, then in theme/collections/breadcrumb.overrides : . ui . breadcrumb a { text-decoration : underline ; }","title":"Using Overrides"},{"location":"theming/integrate-third-party/","text":"Integrate third party React components and related CSS resources # Note This documentation is a work in progress. Please consider to contribute to this documentation.","title":"Integrate third party React components and related CSS resources"},{"location":"theming/integrate-third-party/#integrate-third-party-react-components-and-related-css-resources","text":"Note This documentation is a work in progress. Please consider to contribute to this documentation.","title":"Integrate third party React components and related CSS resources"},{"location":"theming/semanticui-theming/","text":"Semantic Theming # As we hinted previously, Semantic UI theming happens in several stages using several layers of inheritance, let's discover each of these layers. Default definitions # Semantic UI defines the default definitions in LESS files making a strong breakdown into components, organized in these categories: globals elements modules views collections behaviors Each category holds a bunch of LESS files, each representing an item from the category. The default definitions are the base for the themes. It is expected that you don't have to modify these definitions in any case. All the customization happens in the next layers. Themes # The Semantic UI themes are modifications on the default definitions that get loaded after them. Using LESS variables and LESS overrides they modify the defaults in a first customization layer. There are several community driven themes that you can use right away . Site Theme # The Site theme is another layer of possible customization that Semantic UI allows you to have. Let's say you have a theme, but you have a project that will require some modifications over that theme. This will be the most common use as in Plone we will use Pastanaga UI theme and we would only want to customize some of it for some project. We can even switch to another existing theme and use a site theme on the top of it (or only use a theme per project). Semantic UI theming engine allows that kind of flexibility.","title":"Semantic UI Theming"},{"location":"theming/semanticui-theming/#semantic-theming","text":"As we hinted previously, Semantic UI theming happens in several stages using several layers of inheritance, let's discover each of these layers.","title":"Semantic Theming"},{"location":"theming/semanticui-theming/#default-definitions","text":"Semantic UI defines the default definitions in LESS files making a strong breakdown into components, organized in these categories: globals elements modules views collections behaviors Each category holds a bunch of LESS files, each representing an item from the category. The default definitions are the base for the themes. It is expected that you don't have to modify these definitions in any case. All the customization happens in the next layers.","title":"Default definitions"},{"location":"theming/semanticui-theming/#themes","text":"The Semantic UI themes are modifications on the default definitions that get loaded after them. Using LESS variables and LESS overrides they modify the defaults in a first customization layer. There are several community driven themes that you can use right away .","title":"Themes"},{"location":"theming/semanticui-theming/#site-theme","text":"The Site theme is another layer of possible customization that Semantic UI allows you to have. Let's say you have a theme, but you have a project that will require some modifications over that theme. This will be the most common use as in Plone we will use Pastanaga UI theme and we would only want to customize some of it for some project. We can even switch to another existing theme and use a site theme on the top of it (or only use a theme per project). Semantic UI theming engine allows that kind of flexibility.","title":"Site Theme"},{"location":"theming/theming-engine/","text":"How does the theming engine work? # It basically uses heavily the LESS precompiler language features. No code is involved (which is good). theme.config # theme.config is where we define which theme we use. We can decide the theme of each of the Semantic UI components. Yes, you read well... The Semantic UI theming engine provides not only global theming but per component. /* Global */ @site : 'default' ; @reset : 'default' ; /* Elements */ @button : 'default' ; @container : 'default' ; @divider : 'default' ; @flag : 'default' ; @header : 'default' ; @icon : 'default' ; @image : 'default' ; // [...] /* Collections */ @breadcrumb : 'default' ; @form : 'default' ; @grid : 'default' ; @menu : 'default' ; @message : 'default' ; @table : 'default' ; /* Modules */ @accordion : 'default' ; @checkbox : 'default' ; @dimmer : 'default' ; @dropdown : 'default' ; @embed : 'default' ; // [...] /* Views */ @ad : 'default' ; @card : 'default' ; @comment : 'default' ; // [...] semantic.less # Semantic UI has uses a single LESS file as entry point: semantic.less this is the root LESS file and pulls all the components that we want to compile. We have to import this file either from the node_modules semantic-ui-less module directory or make a local copy of it locally. More on this later. theme.less # theme.less does all the Semantic UI theming magic. It controls all the Semantic UI workflow that each component has to comply with. It loads all the files inheritance in the correct order and applies it properly.","title":"Theming Engine"},{"location":"theming/theming-engine/#how-does-the-theming-engine-work","text":"It basically uses heavily the LESS precompiler language features. No code is involved (which is good).","title":"How does the theming engine work?"},{"location":"theming/theming-engine/#themeconfig","text":"theme.config is where we define which theme we use. We can decide the theme of each of the Semantic UI components. Yes, you read well... The Semantic UI theming engine provides not only global theming but per component. /* Global */ @site : 'default' ; @reset : 'default' ; /* Elements */ @button : 'default' ; @container : 'default' ; @divider : 'default' ; @flag : 'default' ; @header : 'default' ; @icon : 'default' ; @image : 'default' ; // [...] /* Collections */ @breadcrumb : 'default' ; @form : 'default' ; @grid : 'default' ; @menu : 'default' ; @message : 'default' ; @table : 'default' ; /* Modules */ @accordion : 'default' ; @checkbox : 'default' ; @dimmer : 'default' ; @dropdown : 'default' ; @embed : 'default' ; // [...] /* Views */ @ad : 'default' ; @card : 'default' ; @comment : 'default' ; // [...]","title":"theme.config"},{"location":"theming/theming-engine/#semanticless","text":"Semantic UI has uses a single LESS file as entry point: semantic.less this is the root LESS file and pulls all the components that we want to compile. We have to import this file either from the node_modules semantic-ui-less module directory or make a local copy of it locally. More on this later.","title":"semantic.less"},{"location":"theming/theming-engine/#themeless","text":"theme.less does all the Semantic UI theming magic. It controls all the Semantic UI workflow that each component has to comply with. It loads all the files inheritance in the correct order and applies it properly.","title":"theme.less"},{"location":"theming/theming-strategy/","text":"Theming Strategy # One approaches the theming of a Volto site usually with a predefined mockup or design from a design agency or an UX/UI designer in the form of Sketch files (a common design and prototyping tool), a series of photoshop or PDFs with the desired result on how the site would look like showing the homepage, landing pages, different views, inner pages, etc. The strategy is to try to map what Volto already provides like the headers, breadcrumbs, footer, main content area, etc to the mockup ones. Then decide which ones will stay as they are (not customized) and which ones will be required to be customized. There is a great chance that the vast majority of components (and main building blocks) will remain the same, only modified by how they look by using basic styling (CSS) theming. As an example, if you need to customize the logo, there is a big chance that you only need to replace and customize the svg file that the Logo.jsx component exposes, without having to customize the whole component. The same might apply for other components or big block components, like the Header.jsx . Before you start, it is advisable to try to familiarize yourself with how Volto is built. Take a look at its building blocks in order to not repeat yourself. Take a tour inside the components folder, and try to map all the components with Volto page. Try to figure out what is the frame, the part that is constant (header, content area, footer), the moving parts, then go to the more complex ones (widgets, forms, etc). Then start theming the components per blocks (header, content area, footer). Try to stick with the container and grid model of Semantic UI, including its breakpoints (and helpers). Use React Semantic UI building blocks whenever it's possible since it will help you things fit together easily. Talks # You might find interesting this talk as resource on how theming works in Volto: https://2018.ploneconf.org/talks/theming-plone-react","title":"Theming strategy"},{"location":"theming/theming-strategy/#theming-strategy","text":"One approaches the theming of a Volto site usually with a predefined mockup or design from a design agency or an UX/UI designer in the form of Sketch files (a common design and prototyping tool), a series of photoshop or PDFs with the desired result on how the site would look like showing the homepage, landing pages, different views, inner pages, etc. The strategy is to try to map what Volto already provides like the headers, breadcrumbs, footer, main content area, etc to the mockup ones. Then decide which ones will stay as they are (not customized) and which ones will be required to be customized. There is a great chance that the vast majority of components (and main building blocks) will remain the same, only modified by how they look by using basic styling (CSS) theming. As an example, if you need to customize the logo, there is a big chance that you only need to replace and customize the svg file that the Logo.jsx component exposes, without having to customize the whole component. The same might apply for other components or big block components, like the Header.jsx . Before you start, it is advisable to try to familiarize yourself with how Volto is built. Take a look at its building blocks in order to not repeat yourself. Take a tour inside the components folder, and try to map all the components with Volto page. Try to figure out what is the frame, the part that is constant (header, content area, footer), the moving parts, then go to the more complex ones (widgets, forms, etc). Then start theming the components per blocks (header, content area, footer). Try to stick with the container and grid model of Semantic UI, including its breakpoints (and helpers). Use React Semantic UI building blocks whenever it's possible since it will help you things fit together easily.","title":"Theming Strategy"},{"location":"theming/theming-strategy/#talks","text":"You might find interesting this talk as resource on how theming works in Volto: https://2018.ploneconf.org/talks/theming-plone-react","title":"Talks"},{"location":"theming/using-third-party-themes/","text":"Using third party libraries/themes different from semantic-ui # You can use Volto with third party libraries or themes written in sass and avoid applying semantic-ui on public facing views. This is made possible by code splitting, where interfaces have a marker CSS class to incapsulate styles and avoid conflicts between semantic-ui and the custom theme you would use. The problem # The main purpuse could be to use a sass based theme like Bootstrap. If you want to load a different styling library using the base Volto configuration, you will load a huge bundle with both having weight and performance issues thus this would likely imply conflicts on base elements as containers. The solution # Volto supports the split of the styles on a different theme: pastanaga-cms-ui . This will load only the CSS needed for Volto's own interfaces like toolbar, sidebar and blocks management. Generally speaking, only for the management interfaces. With this different theme, the end user interfaces will be free to be styled with your custom styles. To accomplish this, you will need to follow two wrapper CSS classes: cms-ui for management interfaces; public-ui for end-user/public facing views. These classes are applied to the body element and in those situations where you are in a management view but a component is a \"public\" one or the opposite, in order to handle the specialization of those. An example of this behavior is the blocks view: you are in a public view because you are not editing the content, but you have the toolbar. Setting up the theme # In your Volto project, customize the file src/theme.js : - import 'semantic-ui-less/semantic.less'; + import '@plone/volto/../theme/themes/pastanaga-cms-ui/extras/cms-ui.semantic.less'; import '@plone/volto/../theme/themes/pastanaga/extras/extras.less' + // Import your site styles, i.e.: + import '../theme/site.scss'; Then, in your theme.config change the following and the needed variables: - @container : 'pastanaga'; + @container : 'pastanaga-cms-ui'; Use sass loader # If you have to load sass, you will need razzle-plugin-scss and you will have to customize razzle.config.js integrating that plugin into razzle configuration. Example: const volto_config = require ( ` ${ voltoPath } /razzle.config` ); module . exports = Object . assign ({}, volto_config , { modify : ( config , { target , dev }, webpack ) => { ... }, plugins : [ { name : 'scss' , options : { sass : { dev : { outputStyle : 'expanded' , sourceMap : true , includePaths : [ 'node_modules' ], }, prod : { outputStyle : 'expanded' , sourceMap : true , includePaths : [ 'node_modules' ], } }, }, }, ], }); Complete example in an active project: https://github.com/RedTurtle/design-volto-theme/blob/master/razzle.config.js In that project, there is the sass loader and the svg loader, too. Including custom styles # In your Volto site theme, include your site custom styles in src/theme.js as described before. Including other styling libraries in most cases will mess font sizes, so it is suggested to add something like: body .cms-ui { .public-ui { font-size : 18px ; font-weight : 300 ; } } to avoid troubles on basical stuff: this is useful to have the correct font in the public-ui component showed while in a cms-view. Tip Consider adding public-ui CSS class as a wrapper for your components, so they will be using your public theme. A good example of this is for the blocks, that need the public-ui styles both while viewing the object and while editing it. On the other hand, many Volto components are using cms-ui . For any other customization, you can put styles in your site theme and override stuff taking advantage of semantic composition engine. Example themes using this approach # https://github.com/RedTurtle/design-volto-theme","title":"Use another theming engine"},{"location":"theming/using-third-party-themes/#using-third-party-librariesthemes-different-from-semantic-ui","text":"You can use Volto with third party libraries or themes written in sass and avoid applying semantic-ui on public facing views. This is made possible by code splitting, where interfaces have a marker CSS class to incapsulate styles and avoid conflicts between semantic-ui and the custom theme you would use.","title":"Using third party libraries/themes different from semantic-ui"},{"location":"theming/using-third-party-themes/#the-problem","text":"The main purpuse could be to use a sass based theme like Bootstrap. If you want to load a different styling library using the base Volto configuration, you will load a huge bundle with both having weight and performance issues thus this would likely imply conflicts on base elements as containers.","title":"The problem"},{"location":"theming/using-third-party-themes/#the-solution","text":"Volto supports the split of the styles on a different theme: pastanaga-cms-ui . This will load only the CSS needed for Volto's own interfaces like toolbar, sidebar and blocks management. Generally speaking, only for the management interfaces. With this different theme, the end user interfaces will be free to be styled with your custom styles. To accomplish this, you will need to follow two wrapper CSS classes: cms-ui for management interfaces; public-ui for end-user/public facing views. These classes are applied to the body element and in those situations where you are in a management view but a component is a \"public\" one or the opposite, in order to handle the specialization of those. An example of this behavior is the blocks view: you are in a public view because you are not editing the content, but you have the toolbar.","title":"The solution"},{"location":"theming/using-third-party-themes/#setting-up-the-theme","text":"In your Volto project, customize the file src/theme.js : - import 'semantic-ui-less/semantic.less'; + import '@plone/volto/../theme/themes/pastanaga-cms-ui/extras/cms-ui.semantic.less'; import '@plone/volto/../theme/themes/pastanaga/extras/extras.less' + // Import your site styles, i.e.: + import '../theme/site.scss'; Then, in your theme.config change the following and the needed variables: - @container : 'pastanaga'; + @container : 'pastanaga-cms-ui';","title":"Setting up the theme"},{"location":"theming/using-third-party-themes/#use-sass-loader","text":"If you have to load sass, you will need razzle-plugin-scss and you will have to customize razzle.config.js integrating that plugin into razzle configuration. Example: const volto_config = require ( ` ${ voltoPath } /razzle.config` ); module . exports = Object . assign ({}, volto_config , { modify : ( config , { target , dev }, webpack ) => { ... }, plugins : [ { name : 'scss' , options : { sass : { dev : { outputStyle : 'expanded' , sourceMap : true , includePaths : [ 'node_modules' ], }, prod : { outputStyle : 'expanded' , sourceMap : true , includePaths : [ 'node_modules' ], } }, }, }, ], }); Complete example in an active project: https://github.com/RedTurtle/design-volto-theme/blob/master/razzle.config.js In that project, there is the sass loader and the svg loader, too.","title":"Use sass loader"},{"location":"theming/using-third-party-themes/#including-custom-styles","text":"In your Volto site theme, include your site custom styles in src/theme.js as described before. Including other styling libraries in most cases will mess font sizes, so it is suggested to add something like: body .cms-ui { .public-ui { font-size : 18px ; font-weight : 300 ; } } to avoid troubles on basical stuff: this is useful to have the correct font in the public-ui component showed while in a cms-view. Tip Consider adding public-ui CSS class as a wrapper for your components, so they will be using your public theme. A good example of this is for the blocks, that need the public-ui styles both while viewing the object and while editing it. On the other hand, many Volto components are using cms-ui . For any other customization, you can put styles in your site theme and override stuff taking advantage of semantic composition engine.","title":"Including custom styles"},{"location":"theming/using-third-party-themes/#example-themes-using-this-approach","text":"https://github.com/RedTurtle/design-volto-theme","title":"Example themes using this approach"},{"location":"upgrade-guide/","text":"Upgrade Guide # This upgrade guide lists all breaking changes in Volto and explains the steps that are necessary to upgrade to the lastest version. Note There are times that updating the Volto boilerplate (the one generated by @plone/create-volto-app ) is enough to fulfill all the changes. If you haven't heavilly modified it, moving things around and copying over your dependencies might do when dealing with upgrades. We keep the generator up to date and in sync with current Volto release. Upgrading to Volto 9.x.x # Internal upgrade to use Razzle 3.3.7 # Note If you haven't customized your razzle.config.js in your project, or have any custom plugin in place, you don't have to do anything. Razzle is the isometric build system for both the server and the client parts on the top of which Volto is built. Recently, it has been under heavy development and some new exciting features have been added to it. The Razzle configuration is now more flexible and extensible than ever. This change might be breaking for you if you customized the razzle.config.js heavily in your projects. Since the new version adds a new way to extend Razzle configuration, you should adapt your extensions to the new way of doing it. See the documentation for more information: https://razzlejs.org/docs/customization#extending-webpack It also unifies the way the things are extended in Razzle plugins as well, so if you are using any official or third party Razzle plugins you should upgrade them to the last version. If you have developed your own Razzle plugin, you should adapt its signature as well. See the documentation for more information: https://razzlejs.org/docs/customization#plugins Razzle 3.3 also has some new experimental features, that will be default in the upcoming Razzle 4, such as the new React Fast Refresh feature, which fixes the annoying breaking of the router after any live refresh. See the documentation of Razzle for more information: https://razzlejs.org/ Changes involved # We need to patch an internal Razzle utility in order to allow the use of non-released Razzle plugins. This feature will be in Razzle 4, unfortunatelly at this point the development the Razzle 3 branch is freezed already so we need to amend the original using the patch. The patch will be obsolete and no longer required once we move to Razzle 4 (see https://github.com/jaredpalmer/razzle/pull/1467 ). Copy (and overwrite) the patches folder into your local project https://github.com/plone/volto/tree/master/patches or, if you want to be more accurate, just copy patches/razzle-plugins.patch file and overwrite patches/patchit.sh file. Babel config housekeeping # Historically, Volto was using \"stage-0\" TC-39 proposals. The configuration was starting showing its age, since Babel 7 dedided to stop maintaining the presets for stages, we moved to use an static configuration instead of a managed one. That lead to a \"living on the edge\" situation since we supported proposals that they didn't make the cut. For more information about the TC39 approval process read ( https://tc39.es/process-document/ ) We decided to put a bit of order to caos and declare that Volto will support only stage-4 approved proposals. They are supported by @babel/preset-env out of the box and provide a good sensible default baseline for Volto. Proposal deprecations: @babel/plugin-proposal-decorators @babel/plugin-proposal-function-bind @babel/plugin-proposal-do-expressions @babel/plugin-proposal-logical-assignment-operators @babel/plugin-proposal-pipeline-operator @babel/plugin-proposal-function-sent In fact, Volto core only used the first one (decorators) and we did the move to not use them long time ago. However, if you were using some of the others, your code will stop compiling. Migrate your code or if you want to use the proposal anyways, you'll need to provide the configuration to your own project (babel.config.js) in your project root folder. You might still be using old-style connecting your components to the Redux store using @connect decorator, in that case, take a look at any connected component in Volto to take a glimpse on how to migrate the code. If you were not using any of the deprecated proposals (the most common use case), then you are good to go and you don't have to do anything. Hoisting problems on some setups # Some people were experimenting weird hoisting issues when installing dependencies. This was caused by Babel deprecated proposals packages and its peer dependencies that sometimes conflicted with other installed packages. Volto's new Babel configuration uses the configuration provided by babel-razzle-preset package (Razzle dependency) and delegates the dependencies management to it, except a few Babel plugins that Volto still needs to work. In order for your projects not have any problem with the new configuration and comply with the new model, you need to remove any local dependency for @babel/core and let Volto handle them. diff --git a/package.json b/package.json --- a/package.json +++ b/package.json @@ -183,7 +183,6 @@ \"node\": \"^10 || ^12 \" }, \"dependencies\": { - \"@babel/core\": \"7.11.1\", \"@plone/volto\": \"8.9.2\", \"mrs-developer\": \"1.2.0\", Recomended browserslist in package.json # Not a breaking change, but you might want to narrow the targets your Votlo project is targeting to. This might improve your build times, as well as your bundle size. This is the recomended browserlist you should include in your local package.json . \"browserslist\" : [ \">1%\" , \"last 4 versions\" , \"Firefox ESR\" , \"not ie 11\" , \"not dead\" ] , Note Please notice that it does not target dead and deprecated browsers by its vendors. New webpack resolver plugin # A new webpack resolver plugin has been integrated with Volto, it reroutes 'local' resolve requests (for example import Something from './Something' ) to 'absolute' resolve requests (like import Something from '@plone/myaddon/Something ). This allows the shadow-based customization mechanisms to work consistently with addons and Volto. This is not a breaking change and it shouldn't affect any existing code, but by its very nature, a resolver plugin has the potential to introduce unexpected behavior. Just be aware of its existence and take it into consideration if you notice anything strange. Content Types icons # Helper method getIcon from Url has been removed in favor of getContentIcon from Content which is now configurable. See contentIcons docs . Upgrading to Volto 8.x.x # Upgrade package.json testing configuration # The dummy-addons-loader.js file has been renamed to jest-addons-loader.js , to be more in line with the rest of the existing files. You should add the following value to the moduleNameMapper property of the jest key in your project's package.json: \"load-volto-addons\": \"<rootDir>/node_modules/@plone/volto/jest-addons-loader.js\", Upgrading to Volto 7.x.x # A misspelled file has been renamed. If you import strickthrough.svg in your project, you'll now find that file at @plone/volto/icons/strikethrough.svg . New webpack resolve alias for Volto themes # As a \"nice to have\", a new resolve alias is provided that points to Volto's theme folder. So, in your project's theme.config file, you can replace: @themesFolder : '../../node_modules/@plone/volto/theme/themes' ; @siteFolder : \"../../theme\" ; @fontPath : \"../../@{theme}/assets/fonts\" ; with: @themesFolder : '~volto-themes' ; @siteFolder : '~@package/../theme' ; @fontPath : \"~volto-themes/@{theme}/assets/fonts\" ; You might consider moving your theme files to a subfolder called site , to prepare for the arrival of addons theming and their overrides. In that case, you would set your @siteFolder to: @siteFolder: '~@package/../theme/site'; Upgrading to Volto 6.x.x # First, update the package.json of your Volto project to Volto 6.x.x. \"dependencies\" : { \"@plone/volto\" : \"6.0.0\" , ... } Note This release includes a number of changes to the internal dependencies. If you have problems building your project, might be that you need to remove your node_modules and, ultimately, remove also your yarn.lock file. Then run again yarn for rebuilding dependencies. Upgrade to Node 12 # We have now dependencies that requires node >=10.19.0 . Although Node 10 has still LTS \"maintenance\" treatment (see https://nodejs.org/en/about/releases/ ) the recommended path is that you use from now on node 12 which is LTS since last October. New Razzle version and related development dependencies # The underlying Razzle package has been upgraded, and although that does not suppose any change in Volto itself, a lot of development dependencies have been upgraded and they should be updated in your local projects as well. Might be that the builds continue working if you don't update them, but it's better for you to do so for a better development experience. Upgrade local dependencies versions # You need to update devDependencies in package.json in your local environment: \"devDependencies\" : { \"eslint-plugin-prettier\" : \"3.1.3\" , \"prettier\" : \"2.0.5\" , \"stylelint-config-idiomatic-order\" : \"8.1.0\" , \"stylelint-config-prettier\" : \"8.0.1\" , \"stylelint-prettier\" : \"1.1.2\" , } and remove entirely the resolutions key: \"resolutions\" : { \"@plone/volto/razzle/webpack-dev-server\" : \"3.2.0\" } Update package.json config # Add this key to the jest.moduleNameMapper : \"jest\" : \"moduleNameMapper\" : { \"@plone/volto/babel\" : \"<rootDir>/node_modules/@plone/volto/babel\" , ... } because new Jest is a bit more picky when importing externals. Prettier # Prettier has been updated, introducing some breaking formatting changes. It's recommended that you upgrade your local version of prettier and reformat your code with it using: yarn prettier:fix Stylelint # stylelint has been upgraded too, and it introduces some changes in the declaration of the styles order. It's recommended that you upgrade your local version of prettier and reformat your code with it using: yarn stylelint:fix CSS modules are not supported anymore # Razzle does not support them anymore, so neither do we. If you need them, you could add a Webpack config in your local razzle.config.js . Update your eslint config # Introduced in the Volto 5 series, it's recommended that you update your local ESLint config. In the past, we used .eslintrc file to do so. In order to support automatically Volto addons, you should remove it and use a JS based config one .eslintrc.js with this contents: const path = require ( 'path' ); const projectRootPath = path . resolve ( '.' ); const packageJson = require ( path . join ( projectRootPath , 'package.json' )); // Extends ESlint configuration for adding the aliases to `src` directories in Volto addons const addonsAliases = []; if ( packageJson . addons ) { const addons = packageJson . addons ; addons . forEach ( addon => { const addonPath = ` ${ addon } /src` ; addonsAliases . push ([ addon , addonPath ]); }); } module . exports = { extends : './node_modules/@plone/volto/.eslintrc' , settings : { 'import/resolver' : { alias : { map : [ [ '@plone/volto' , '@plone/volto/src' ], ... addonsAliases , [ '@package' , './src' ], ], extensions : [ '.js' , '.jsx' , '.json' ], }, 'babel-plugin-root-import' : { rootPathSuffix : 'src' , }, }, }, }; New wrappers in block editor # We have improved the overall UX of the block drag and drop feature by using the library react-beautiful-dnd in the block editor. It introduces new wrappers (belonging to the lib machinery) in the structure. The original structure and class names are still in there (as children of these wrappers) to maintain maximum backwards compatibility. Those might be cleaned up in next major versions, so if for some reason you have customized the styling of your blocks in edit mode relying in the old structure, you might want to review and adapt them. Update config.js # Note This is required since Volto version 6.1.0 1541 Add these to the config.js of your project: export const addonRoutes = []; export const addonReducers = {}; Upgrading to Volto 5.x.x # First, update the package.json of your Volto project to Volto 5.x.x. \"dependencies\" : { \"@plone/volto\" : \"5.0.0\" , ... } New lazy loading boilerplate # Volto is now capable of splitting and lazy load components. This allows for better performance and reduced bundle sizes, the client also has to parse and load less code, improving the user experience, specially on mobile devices. The boilerplate includes changes in the structural foundation of Volto itself. So if you have updated in your projects any of these components: src/helpers/Html/Html.jsx src/components/theme/App/App.jsx src/server.jsx src/client.jsx you should adapt them to the newests changes in Volto source code. You can do that by diffing the new ones with yours. Testing lazy load components # The whole process has been designed to have a minimal impact in existing projects. However, only a thing should be changed in your components tests. Specially if your components are composed of original Volto components (not SemanticUI ones, though). You should adapt them by mocking the Volto component or resolve (await) for them in an async construction before the test is fired. See this Codepen example: https://codesandbox.io/s/loadable-async-tests-l2bx9 import React from \"react\" ; import { render } from \"@testing-library/react\" ; import App from \"./App\" ; import { Component1 , Component2 } from \"./components\" ; describe ( \"CustomComponent\" , () => { it ( \"rendered lazily\" , async () => { const { container , getByText } = render (< App />); await Component1 ; await Component2 ; expect ( container . firstChild ). toMatchSnapshot (); expect ( getByText ( \"Component1\" )); expect ( getByText ( \"Component2\" )); }); This is also another pattern used in Volto core for testing, you can transform your test in async aware like this: --- a/src/components/manage/Preferences/PersonalPreferences.test.jsx +++ b/src/components/manage/Preferences/PersonalPreferences.test.jsx @@ -3,6 +3,7 @@ import renderer from 'react-test-renderer'; import { Provider } from 'react-intl-redux'; import configureStore from 'redux-mock-store'; import { MemoryRouter } from 'react-router-dom'; +import { wait } from '@testing-library/react'; import PersonalPreferences from './PersonalPreferences'; @@ -13,7 +14,7 @@ jest.mock('react-portal', () => ({ })); describe('PersonalPreferences', () => { - it('renders a personal preferences component', () => { + it('renders a personal preferences component', async () => { const store = mockStore({ intl: { locale: 'en', @@ -36,7 +37,8 @@ describe('PersonalPreferences', () => { </MemoryRouter> </Provider>, ); - const json = component.toJSON(); - expect(json).toMatchSnapshot(); + await wait(() => { + expect(component.toJSON()).toMatchSnapshot(); + }); }); }); Helmet title now it's centralized in View.jsx # All the calls for update the title in the document performed by Helmet are now centralized in the View.jsx components. It's recommended to remove all the Helmet calls for updating the title from your components specially if you are using some of the SEO addons for Volto, since not doing that could interfere with them. Upgrading to Volto 4.x.x # First, update your package.json to Volto 4.x.x. \"dependencies\" : { \"@plone/volto\" : \"4.0.0\" , ... } New initial blocks per content type setting in Alpha 37 # Not breaking change, but now there's a new setting in Blocks, initialBlocks where you can define a the initial blocks for all content types. You can override the default ('title' and a 'text' block) and provide your own by modifying the configuration object: const initialBlocks = { Document : [ 'leadimage' , 'title' , 'text' , 'listing' ] }; provide an empty object if you don't want to define any additional initial blocks and keep the default. const initialBlocks = {}; ImageSidebar moved to Image Block directory in Alpha 29 # For better resource grouping, the ImageSidebar component has been moved to the Image block component directory: components/manage/Blocks/Image Copy yarn.lock from volto-starter-kit in Alpha 17 # Due to changes in the dependency tree, it's required to use an specific yarn.lock file by deleting it and copy the one here: https://github.com/plone/volto-starter-kit/blob/master/yarn.lock before upgrading to Volto alpha 17. Forked Helmet into Volto core # Due to the inactivity of the Helmet project, we decided to fork it to the core. It's part of the Volto helpers now. You have to update your imports accordingly. Please notice that now it's a named import: --- a/src/components/Views/ReportView.jsx +++ b/src/components/Views/ReportView.jsx @@ -1,6 +1,6 @@ import React from 'react'; import PropTypes from 'prop-types'; -import Helmet from 'react-helmet'; +import { Helmet } from '@plone/volto/helpers'; import { defineMessages, injectIntl, FormattedMessage } from 'react-intl'; import { format, parse } from 'date-fns'; import { filter, map } from 'lodash'; Alpha 16 is a brownbag release # There was a problem with the projects using Volto eslint config when upgrading to latest versions related to typescript, we will take of that in the near future. So skip this version. Stylelint and prettier config in Alpha 14 # In your project's boilerplate, you need to update the stylelint and prettier configuration accordingly to the changes made in Alpha 14 in package.json like this: diff --git a/package.json b/package.json index 7c8194c..5c63469 100644 --- a/package.json +++ b/package.json @@ -46,26 +46,51 @@ }, \"prettier\": { \"trailingComma\": \"all\", - \"singleQuote\": true + \"singleQuote\": true, + \"overrides\": [ + { + \"files\": \"*.overrides\", + \"options\": { + \"parser\": \"less\" + } + } + ] }, \"stylelint\": { \"extends\": [ - \"stylelint-config-standard\", - \"stylelint-config-idiomatic-order\", - \"./node_modules/prettier-stylelint/config.js\" - ] + \"stylelint-config-idiomatic-order\" + ], + \"plugins\": [ + \"stylelint-prettier\" + ], + \"rules\": { + \"prettier/prettier\": true, + \"rule-empty-line-before\": [ + \"always-multi-line\", + { + \"except\": [ + \"first-nested\" + ], + \"ignore\": [ + \"after-comment\" + ] + } + ] + }, + \"ignoreFiles\": \"theme/themes/default/**/*.overrides\" }, \"engines\": { \"node\": \"^10 || ^12\" }, \"dependencies\": { - \"@plone/volto\": \"4.0.0-alpha.10\" + \"@plone/volto\": \"4.0.0-alpha.14\" }, \"devDependencies\": { \"eslint-plugin-prettier\": \"3.0.1\", - \"postcss-overrides\": \"3.1.4\", - \"prettier\": \"1.17.0\", - \"prettier-stylelint\": \"0.4.2\" + \"prettier\": \"1.19.1\", + \"stylelint-config-idiomatic-order\": \"6.2.0\", + \"stylelint-config-prettier\": \"6.0.0\", + \"stylelint-prettier\": \"1.1.1\" }, \"resolutions\": { \"@plone/volto/razzle/webpack-dev-server\": \"3.2.0\" Note If you are linting activelly your project, the build might be broken after this update. You should run: $ yarn prettier:fix $ yarn stylelint:fix then commit the changes. openObjectBrowser API change in Alpha 11 # The API of the ObjectBrowser component changed in alpha 11 to make it more flexible. In case you had custom blocks using it, you have to update the call in case you were using a link mode: @@ -42,7 +42,7 @@ const OtherComp = ({ href: '', }); } - : () => openObjectBrowser('link') + : () => openObjectBrowser({ mode: 'link' }) } onChange={(name, value) => { onChangeBlock(block, { See the blocks section for more details. Renaming Tiles into Blocks # An internal renaming to use the term Blocks everywhere was done to unify naming through the code a and the documentation. Plone RESTAPI was updated to that purpose too, and running an upgrade step (do so in Plone's Addons control panel) is required in order to migrate the data. No step is required if you are using a brand new ZODB. This is the versions compatibility table across all the packages involved: Volto 4 - plone.restapi >= 5.0.0 - kitconcept.voltodemo >= 2.0 Note The renaming happened in Volto 4 alpha.10 and plone.restapi 5.0.0. Volto 4 alpha versions under that release use older versions of plone.restapi and kitconcept.voltodemo , however if you are using alpha releases it's recommended to upgrade to latest alpha or the final release of Volto 4. The project configuration should also be updated, in your src/config.js : diff --git a/src/config.js b/src/config.js index f1fe9c2..9517c38 100644 --- a/src/config.js +++ b/src/config.js @@ -16,7 +16,7 @@ import { settings as defaultSettings, views as defaultViews, widgets as defaultWidgets, - tiles as defaultTiles, + blocks as defaultBlocks, } from '@plone/volto/config'; export const settings = { @@ -31,6 +31,6 @@ export const widgets = { ...defaultWidgets, }; -export const tiles = { - ...defaultTiles, +export const blocks = { + ...defaultBlocks, }; Add theme customization to your project # Volto 4 now also expects a file named src/theme.js with this content by default: import 'semantic-ui-less/semantic.less' ; import '@plone/volto/../theme/themes/pastanaga/extras/extras.less' ; Remove enzyme configuration # Enzyme has been removed, in favor of @testing-library/react , and the configuration should be removed in package.json : diff --git a/package.json b/package.json index 27c7f8d..8f5f088 100644 --- a/package.json +++ b/package.json @@ -44,9 +44,6 @@ \"default\", \"jest-junit\" ], - \"snapshotSerializers\": [ - \"enzyme-to-json/serializer\" - ], \"transform\": { \"^.+\\\\.js(x)?$\": \"babel-jest\", \"^.+\\\\.css$\": \"jest-css-modules\", Blocks engine - Blocks configuration object # The blocks engine was updated and there are some important breaking changes, in case that you've developed custom blocks. The configuration object is now unified and expresses all the properties to model a block. This is how a block in the defaultBlocks object looks like: const defaultBlocks = { title : { id : 'title' , // The name (id) of the block title : 'Title' , // The display name of the block icon : titleSVG , // The icon used in the block chooser group : 'text' , // The group (blocks can be grouped, displayed in the chooser) view : ViewTitleBlock , // The view mode component edit : EditTitleBlock , // The edit mode component restricted : false , // If the block is restricted, it won't show in in the chooser mostUsed : false , // A meta group `most used`, appearing at the top of the chooser blockHasOwnFocusManagement : false , // Set this to true if the block manages its own focus security : { addPermission : [], // Future proof (not implemented yet) add user permission role(s) view : [], // Future proof (not implemented yet) view user role(s) }, }, ... There is an additional object groupBlocksOrder that contains an array with the order that the blocks group should appear: const groupBlocksOrder = [ { id : 'mostUsed' , title : 'Most used' }, { id : 'text' , title : 'Text' }, { id : 'media' , title : 'Media' }, { id : 'common' , title : 'Common' }, ]; You should adapt and merge the configuration of your own custom blocks to match the defaultBlocks and groupBlocksOrder one. You can modify the order of the groups and create your own as well. Blocks engine - Simplification of the edit blocks wrapper # The edit block wrapper boilerplate was quite big, and for bootstrap an edit block you had to copy it from an existing block. Now all this boilerplate has been transferred to the Blocks Engine, so bootstrapping the edit component of a block is easier and do not require any pre-existing code. In order to upgrade your blocks you should simplify the outter <div> (took as example the Title block): --- a/src/components/manage/Blocks/Title/Edit.jsx +++ b/src/components/manage/Blocks/Title/Edit.jsx @@ -138,11 +138,7 @@ class Edit extends Component { return <div />; } return ( - <div - role=\"presentation\" - onClick={() => this.props.onSelectBlock(this.props.block)} - className={cx('block title', { selected: this.props.selected })} - > + <> <Editor onChange={this.onChange} editorState={this.state.editorState} @@ -185,7 +181,7 @@ class Edit extends Component { this.node = node; }} /> - </div> + </> ); } } The blocks engine now takes care for the keyboard navigation of the blocks, so you need to remove the outter <div> from your custom block, then your block doesn't have to react to the change on this.props.selected either, because it's also something that the blocks engine already does for you. The focus management is also transferred to the engine, so no needed for your block to manage the focus. However, if your block does indeed require to manage its own focus, then you should mark it with the blockHasOwnFocusManagement property in the blocks configuration object: text : { id : 'text' , title : 'Text' , icon : textSVG , group : 'text' , view : ViewTextBlock , edit : EditTextBlock , restricted : false , mostUsed : false , blockHasOwnFocusManagement : true , security : { addPermission : [], view : [], }, }, Default view renaming # The default view for content types DocumentView.jsx has been renamed to a more appropiate DefaultView.jsx . This view contains the code for rendering blocks in case the content type has been Blocks enabled. Enable Blocks on your content types by composing the view of your content type using DefaultView component. Deprecations # The old messages container has been removed since it's not used anymore by Volto. We changed it to use Toast library. Improve the Pastanaga Editor block wrapper container layout, deprecating the hack .ui.wrapper > * . Upgrading to Volto 3.x # Volto was upgraded to use Razzle 3.0.0 which is not a breaking change itself, but it forces to some changes in the boilerplate on your Volto projects. You should change the babel config by deleting .babelrc file and creating a new file babel.config.js with these contents: module . exports = require ( '@plone/volto/babel' ); Then update your package.json to Volto 3.x. \"dependencies\" : { \"@plone/volto\" : \"3.0.0\" , ... } Volto 3.x is compatible with the new changes introduced in the vocabularies endpoint in plone.restapi 4.0.0. If you custom build a widget based in the Volto ones, you should update them as well. Volto updated its own widget set to support them: components/manage/Widgets/ArrayWidget components/manage/Widgets/SelectWidget components/manage/Widgets/TokenWidget They all use react-select third party library for render it. Upgrading to Volto 2.x # Improved Blocks HOC # The Blocks HOC (High Order Component) was changed to lift off some of the features from the blocks themselves and now it takes care of them by its own. The delete block feature was moved to it The keylisteners for navigating through blocks was moved to it The properties passed down to the blocks are improved and documented This change only applies to your existing blocks, you have to update them accordingly by delete the trash icon and action from the end of your blocks { this . props . selected && ( < Button icon basic onClick = {() => this . props . onDeleteBlock ( this . props . block )} className = \"block-delete-button\" > < Icon name = { trashSVG } size = \"18px\" /> </ Button > )} Modify the parent element of your block making this changes: < div role = \"presentation\" onClick = {() => this . props . onSelectBlock ( this . props . block )} className = { cx ( 'block hero' , { selected : this . props . selected , })} tabIndex = { 0 } onKeyDown = { e => this . props . handleKeyDown ( e , this . props . index , this . props . block , this . node ) } ref = { node => { this . node = node ; }} > Add the keylisteners to the parent element of your block onKeyDown = { e => this . props . handleKeyDown ( e , this . props . index , this . props . block , this . node ) } Add a ref to it and assign it to this.node . ref = { node => { this . node = node ; }} Add a proper role for it role = \"presentation\" Take a look into the implementation of the default Volto blocks to get a grasp on all the edge cases related to keyboard navigation and how to deal with them. Reordering of the internal CSS, added an extra # The internal Volto CSS has been tidied up and reordered, for that reason, some other extras have been introduced and the theme.config in your project needs to be updated by making sure you have these two extras in the theme.config file: /* Extras */ @main : 'pastanaga' ; @custom : 'pastanaga' ;","title":"Upgrade Guide"},{"location":"upgrade-guide/#upgrade-guide","text":"This upgrade guide lists all breaking changes in Volto and explains the steps that are necessary to upgrade to the lastest version. Note There are times that updating the Volto boilerplate (the one generated by @plone/create-volto-app ) is enough to fulfill all the changes. If you haven't heavilly modified it, moving things around and copying over your dependencies might do when dealing with upgrades. We keep the generator up to date and in sync with current Volto release.","title":"Upgrade Guide"},{"location":"upgrade-guide/#upgrading-to-volto-9xx","text":"","title":"Upgrading to Volto 9.x.x"},{"location":"upgrade-guide/#internal-upgrade-to-use-razzle-337","text":"Note If you haven't customized your razzle.config.js in your project, or have any custom plugin in place, you don't have to do anything. Razzle is the isometric build system for both the server and the client parts on the top of which Volto is built. Recently, it has been under heavy development and some new exciting features have been added to it. The Razzle configuration is now more flexible and extensible than ever. This change might be breaking for you if you customized the razzle.config.js heavily in your projects. Since the new version adds a new way to extend Razzle configuration, you should adapt your extensions to the new way of doing it. See the documentation for more information: https://razzlejs.org/docs/customization#extending-webpack It also unifies the way the things are extended in Razzle plugins as well, so if you are using any official or third party Razzle plugins you should upgrade them to the last version. If you have developed your own Razzle plugin, you should adapt its signature as well. See the documentation for more information: https://razzlejs.org/docs/customization#plugins Razzle 3.3 also has some new experimental features, that will be default in the upcoming Razzle 4, such as the new React Fast Refresh feature, which fixes the annoying breaking of the router after any live refresh. See the documentation of Razzle for more information: https://razzlejs.org/","title":"Internal upgrade to use Razzle 3.3.7"},{"location":"upgrade-guide/#changes-involved","text":"We need to patch an internal Razzle utility in order to allow the use of non-released Razzle plugins. This feature will be in Razzle 4, unfortunatelly at this point the development the Razzle 3 branch is freezed already so we need to amend the original using the patch. The patch will be obsolete and no longer required once we move to Razzle 4 (see https://github.com/jaredpalmer/razzle/pull/1467 ). Copy (and overwrite) the patches folder into your local project https://github.com/plone/volto/tree/master/patches or, if you want to be more accurate, just copy patches/razzle-plugins.patch file and overwrite patches/patchit.sh file.","title":"Changes involved"},{"location":"upgrade-guide/#babel-config-housekeeping","text":"Historically, Volto was using \"stage-0\" TC-39 proposals. The configuration was starting showing its age, since Babel 7 dedided to stop maintaining the presets for stages, we moved to use an static configuration instead of a managed one. That lead to a \"living on the edge\" situation since we supported proposals that they didn't make the cut. For more information about the TC39 approval process read ( https://tc39.es/process-document/ ) We decided to put a bit of order to caos and declare that Volto will support only stage-4 approved proposals. They are supported by @babel/preset-env out of the box and provide a good sensible default baseline for Volto. Proposal deprecations: @babel/plugin-proposal-decorators @babel/plugin-proposal-function-bind @babel/plugin-proposal-do-expressions @babel/plugin-proposal-logical-assignment-operators @babel/plugin-proposal-pipeline-operator @babel/plugin-proposal-function-sent In fact, Volto core only used the first one (decorators) and we did the move to not use them long time ago. However, if you were using some of the others, your code will stop compiling. Migrate your code or if you want to use the proposal anyways, you'll need to provide the configuration to your own project (babel.config.js) in your project root folder. You might still be using old-style connecting your components to the Redux store using @connect decorator, in that case, take a look at any connected component in Volto to take a glimpse on how to migrate the code. If you were not using any of the deprecated proposals (the most common use case), then you are good to go and you don't have to do anything.","title":"Babel config housekeeping"},{"location":"upgrade-guide/#hoisting-problems-on-some-setups","text":"Some people were experimenting weird hoisting issues when installing dependencies. This was caused by Babel deprecated proposals packages and its peer dependencies that sometimes conflicted with other installed packages. Volto's new Babel configuration uses the configuration provided by babel-razzle-preset package (Razzle dependency) and delegates the dependencies management to it, except a few Babel plugins that Volto still needs to work. In order for your projects not have any problem with the new configuration and comply with the new model, you need to remove any local dependency for @babel/core and let Volto handle them. diff --git a/package.json b/package.json --- a/package.json +++ b/package.json @@ -183,7 +183,6 @@ \"node\": \"^10 || ^12 \" }, \"dependencies\": { - \"@babel/core\": \"7.11.1\", \"@plone/volto\": \"8.9.2\", \"mrs-developer\": \"1.2.0\",","title":"Hoisting problems on some setups"},{"location":"upgrade-guide/#recomended-browserslist-in-packagejson","text":"Not a breaking change, but you might want to narrow the targets your Votlo project is targeting to. This might improve your build times, as well as your bundle size. This is the recomended browserlist you should include in your local package.json . \"browserslist\" : [ \">1%\" , \"last 4 versions\" , \"Firefox ESR\" , \"not ie 11\" , \"not dead\" ] , Note Please notice that it does not target dead and deprecated browsers by its vendors.","title":"Recomended browserslist in package.json"},{"location":"upgrade-guide/#new-webpack-resolver-plugin","text":"A new webpack resolver plugin has been integrated with Volto, it reroutes 'local' resolve requests (for example import Something from './Something' ) to 'absolute' resolve requests (like import Something from '@plone/myaddon/Something ). This allows the shadow-based customization mechanisms to work consistently with addons and Volto. This is not a breaking change and it shouldn't affect any existing code, but by its very nature, a resolver plugin has the potential to introduce unexpected behavior. Just be aware of its existence and take it into consideration if you notice anything strange.","title":"New webpack resolver plugin"},{"location":"upgrade-guide/#content-types-icons","text":"Helper method getIcon from Url has been removed in favor of getContentIcon from Content which is now configurable. See contentIcons docs .","title":"Content Types icons"},{"location":"upgrade-guide/#upgrading-to-volto-8xx","text":"","title":"Upgrading to Volto 8.x.x"},{"location":"upgrade-guide/#upgrade-packagejson-testing-configuration","text":"The dummy-addons-loader.js file has been renamed to jest-addons-loader.js , to be more in line with the rest of the existing files. You should add the following value to the moduleNameMapper property of the jest key in your project's package.json: \"load-volto-addons\": \"<rootDir>/node_modules/@plone/volto/jest-addons-loader.js\",","title":"Upgrade package.json testing configuration"},{"location":"upgrade-guide/#upgrading-to-volto-7xx","text":"A misspelled file has been renamed. If you import strickthrough.svg in your project, you'll now find that file at @plone/volto/icons/strikethrough.svg .","title":"Upgrading to Volto 7.x.x"},{"location":"upgrade-guide/#new-webpack-resolve-alias-for-volto-themes","text":"As a \"nice to have\", a new resolve alias is provided that points to Volto's theme folder. So, in your project's theme.config file, you can replace: @themesFolder : '../../node_modules/@plone/volto/theme/themes' ; @siteFolder : \"../../theme\" ; @fontPath : \"../../@{theme}/assets/fonts\" ; with: @themesFolder : '~volto-themes' ; @siteFolder : '~@package/../theme' ; @fontPath : \"~volto-themes/@{theme}/assets/fonts\" ; You might consider moving your theme files to a subfolder called site , to prepare for the arrival of addons theming and their overrides. In that case, you would set your @siteFolder to: @siteFolder: '~@package/../theme/site';","title":"New webpack resolve alias for Volto themes"},{"location":"upgrade-guide/#upgrading-to-volto-6xx","text":"First, update the package.json of your Volto project to Volto 6.x.x. \"dependencies\" : { \"@plone/volto\" : \"6.0.0\" , ... } Note This release includes a number of changes to the internal dependencies. If you have problems building your project, might be that you need to remove your node_modules and, ultimately, remove also your yarn.lock file. Then run again yarn for rebuilding dependencies.","title":"Upgrading to Volto 6.x.x"},{"location":"upgrade-guide/#upgrade-to-node-12","text":"We have now dependencies that requires node >=10.19.0 . Although Node 10 has still LTS \"maintenance\" treatment (see https://nodejs.org/en/about/releases/ ) the recommended path is that you use from now on node 12 which is LTS since last October.","title":"Upgrade to Node 12"},{"location":"upgrade-guide/#new-razzle-version-and-related-development-dependencies","text":"The underlying Razzle package has been upgraded, and although that does not suppose any change in Volto itself, a lot of development dependencies have been upgraded and they should be updated in your local projects as well. Might be that the builds continue working if you don't update them, but it's better for you to do so for a better development experience.","title":"New Razzle version and related development dependencies"},{"location":"upgrade-guide/#upgrade-local-dependencies-versions","text":"You need to update devDependencies in package.json in your local environment: \"devDependencies\" : { \"eslint-plugin-prettier\" : \"3.1.3\" , \"prettier\" : \"2.0.5\" , \"stylelint-config-idiomatic-order\" : \"8.1.0\" , \"stylelint-config-prettier\" : \"8.0.1\" , \"stylelint-prettier\" : \"1.1.2\" , } and remove entirely the resolutions key: \"resolutions\" : { \"@plone/volto/razzle/webpack-dev-server\" : \"3.2.0\" }","title":"Upgrade local dependencies versions"},{"location":"upgrade-guide/#update-packagejson-config","text":"Add this key to the jest.moduleNameMapper : \"jest\" : \"moduleNameMapper\" : { \"@plone/volto/babel\" : \"<rootDir>/node_modules/@plone/volto/babel\" , ... } because new Jest is a bit more picky when importing externals.","title":"Update package.json config"},{"location":"upgrade-guide/#prettier","text":"Prettier has been updated, introducing some breaking formatting changes. It's recommended that you upgrade your local version of prettier and reformat your code with it using: yarn prettier:fix","title":"Prettier"},{"location":"upgrade-guide/#stylelint","text":"stylelint has been upgraded too, and it introduces some changes in the declaration of the styles order. It's recommended that you upgrade your local version of prettier and reformat your code with it using: yarn stylelint:fix","title":"Stylelint"},{"location":"upgrade-guide/#css-modules-are-not-supported-anymore","text":"Razzle does not support them anymore, so neither do we. If you need them, you could add a Webpack config in your local razzle.config.js .","title":"CSS modules are not supported anymore"},{"location":"upgrade-guide/#update-your-eslint-config","text":"Introduced in the Volto 5 series, it's recommended that you update your local ESLint config. In the past, we used .eslintrc file to do so. In order to support automatically Volto addons, you should remove it and use a JS based config one .eslintrc.js with this contents: const path = require ( 'path' ); const projectRootPath = path . resolve ( '.' ); const packageJson = require ( path . join ( projectRootPath , 'package.json' )); // Extends ESlint configuration for adding the aliases to `src` directories in Volto addons const addonsAliases = []; if ( packageJson . addons ) { const addons = packageJson . addons ; addons . forEach ( addon => { const addonPath = ` ${ addon } /src` ; addonsAliases . push ([ addon , addonPath ]); }); } module . exports = { extends : './node_modules/@plone/volto/.eslintrc' , settings : { 'import/resolver' : { alias : { map : [ [ '@plone/volto' , '@plone/volto/src' ], ... addonsAliases , [ '@package' , './src' ], ], extensions : [ '.js' , '.jsx' , '.json' ], }, 'babel-plugin-root-import' : { rootPathSuffix : 'src' , }, }, }, };","title":"Update your eslint config"},{"location":"upgrade-guide/#new-wrappers-in-block-editor","text":"We have improved the overall UX of the block drag and drop feature by using the library react-beautiful-dnd in the block editor. It introduces new wrappers (belonging to the lib machinery) in the structure. The original structure and class names are still in there (as children of these wrappers) to maintain maximum backwards compatibility. Those might be cleaned up in next major versions, so if for some reason you have customized the styling of your blocks in edit mode relying in the old structure, you might want to review and adapt them.","title":"New wrappers in block editor"},{"location":"upgrade-guide/#update-configjs","text":"Note This is required since Volto version 6.1.0 1541 Add these to the config.js of your project: export const addonRoutes = []; export const addonReducers = {};","title":"Update config.js"},{"location":"upgrade-guide/#upgrading-to-volto-5xx","text":"First, update the package.json of your Volto project to Volto 5.x.x. \"dependencies\" : { \"@plone/volto\" : \"5.0.0\" , ... }","title":"Upgrading to Volto 5.x.x"},{"location":"upgrade-guide/#new-lazy-loading-boilerplate","text":"Volto is now capable of splitting and lazy load components. This allows for better performance and reduced bundle sizes, the client also has to parse and load less code, improving the user experience, specially on mobile devices. The boilerplate includes changes in the structural foundation of Volto itself. So if you have updated in your projects any of these components: src/helpers/Html/Html.jsx src/components/theme/App/App.jsx src/server.jsx src/client.jsx you should adapt them to the newests changes in Volto source code. You can do that by diffing the new ones with yours.","title":"New lazy loading boilerplate"},{"location":"upgrade-guide/#testing-lazy-load-components","text":"The whole process has been designed to have a minimal impact in existing projects. However, only a thing should be changed in your components tests. Specially if your components are composed of original Volto components (not SemanticUI ones, though). You should adapt them by mocking the Volto component or resolve (await) for them in an async construction before the test is fired. See this Codepen example: https://codesandbox.io/s/loadable-async-tests-l2bx9 import React from \"react\" ; import { render } from \"@testing-library/react\" ; import App from \"./App\" ; import { Component1 , Component2 } from \"./components\" ; describe ( \"CustomComponent\" , () => { it ( \"rendered lazily\" , async () => { const { container , getByText } = render (< App />); await Component1 ; await Component2 ; expect ( container . firstChild ). toMatchSnapshot (); expect ( getByText ( \"Component1\" )); expect ( getByText ( \"Component2\" )); }); This is also another pattern used in Volto core for testing, you can transform your test in async aware like this: --- a/src/components/manage/Preferences/PersonalPreferences.test.jsx +++ b/src/components/manage/Preferences/PersonalPreferences.test.jsx @@ -3,6 +3,7 @@ import renderer from 'react-test-renderer'; import { Provider } from 'react-intl-redux'; import configureStore from 'redux-mock-store'; import { MemoryRouter } from 'react-router-dom'; +import { wait } from '@testing-library/react'; import PersonalPreferences from './PersonalPreferences'; @@ -13,7 +14,7 @@ jest.mock('react-portal', () => ({ })); describe('PersonalPreferences', () => { - it('renders a personal preferences component', () => { + it('renders a personal preferences component', async () => { const store = mockStore({ intl: { locale: 'en', @@ -36,7 +37,8 @@ describe('PersonalPreferences', () => { </MemoryRouter> </Provider>, ); - const json = component.toJSON(); - expect(json).toMatchSnapshot(); + await wait(() => { + expect(component.toJSON()).toMatchSnapshot(); + }); }); });","title":"Testing lazy load components"},{"location":"upgrade-guide/#helmet-title-now-its-centralized-in-viewjsx","text":"All the calls for update the title in the document performed by Helmet are now centralized in the View.jsx components. It's recommended to remove all the Helmet calls for updating the title from your components specially if you are using some of the SEO addons for Volto, since not doing that could interfere with them.","title":"Helmet title now it's centralized in View.jsx"},{"location":"upgrade-guide/#upgrading-to-volto-4xx","text":"First, update your package.json to Volto 4.x.x. \"dependencies\" : { \"@plone/volto\" : \"4.0.0\" , ... }","title":"Upgrading to Volto 4.x.x"},{"location":"upgrade-guide/#new-initial-blocks-per-content-type-setting-in-alpha-37","text":"Not breaking change, but now there's a new setting in Blocks, initialBlocks where you can define a the initial blocks for all content types. You can override the default ('title' and a 'text' block) and provide your own by modifying the configuration object: const initialBlocks = { Document : [ 'leadimage' , 'title' , 'text' , 'listing' ] }; provide an empty object if you don't want to define any additional initial blocks and keep the default. const initialBlocks = {};","title":"New initial blocks per content type setting in Alpha 37"},{"location":"upgrade-guide/#imagesidebar-moved-to-image-block-directory-in-alpha-29","text":"For better resource grouping, the ImageSidebar component has been moved to the Image block component directory: components/manage/Blocks/Image","title":"ImageSidebar moved to Image Block directory in Alpha 29"},{"location":"upgrade-guide/#copy-yarnlock-from-volto-starter-kit-in-alpha-17","text":"Due to changes in the dependency tree, it's required to use an specific yarn.lock file by deleting it and copy the one here: https://github.com/plone/volto-starter-kit/blob/master/yarn.lock before upgrading to Volto alpha 17.","title":"Copy yarn.lock from volto-starter-kit in Alpha 17"},{"location":"upgrade-guide/#forked-helmet-into-volto-core","text":"Due to the inactivity of the Helmet project, we decided to fork it to the core. It's part of the Volto helpers now. You have to update your imports accordingly. Please notice that now it's a named import: --- a/src/components/Views/ReportView.jsx +++ b/src/components/Views/ReportView.jsx @@ -1,6 +1,6 @@ import React from 'react'; import PropTypes from 'prop-types'; -import Helmet from 'react-helmet'; +import { Helmet } from '@plone/volto/helpers'; import { defineMessages, injectIntl, FormattedMessage } from 'react-intl'; import { format, parse } from 'date-fns'; import { filter, map } from 'lodash';","title":"Forked Helmet into Volto core"},{"location":"upgrade-guide/#alpha-16-is-a-brownbag-release","text":"There was a problem with the projects using Volto eslint config when upgrading to latest versions related to typescript, we will take of that in the near future. So skip this version.","title":"Alpha 16 is a brownbag release"},{"location":"upgrade-guide/#stylelint-and-prettier-config-in-alpha-14","text":"In your project's boilerplate, you need to update the stylelint and prettier configuration accordingly to the changes made in Alpha 14 in package.json like this: diff --git a/package.json b/package.json index 7c8194c..5c63469 100644 --- a/package.json +++ b/package.json @@ -46,26 +46,51 @@ }, \"prettier\": { \"trailingComma\": \"all\", - \"singleQuote\": true + \"singleQuote\": true, + \"overrides\": [ + { + \"files\": \"*.overrides\", + \"options\": { + \"parser\": \"less\" + } + } + ] }, \"stylelint\": { \"extends\": [ - \"stylelint-config-standard\", - \"stylelint-config-idiomatic-order\", - \"./node_modules/prettier-stylelint/config.js\" - ] + \"stylelint-config-idiomatic-order\" + ], + \"plugins\": [ + \"stylelint-prettier\" + ], + \"rules\": { + \"prettier/prettier\": true, + \"rule-empty-line-before\": [ + \"always-multi-line\", + { + \"except\": [ + \"first-nested\" + ], + \"ignore\": [ + \"after-comment\" + ] + } + ] + }, + \"ignoreFiles\": \"theme/themes/default/**/*.overrides\" }, \"engines\": { \"node\": \"^10 || ^12\" }, \"dependencies\": { - \"@plone/volto\": \"4.0.0-alpha.10\" + \"@plone/volto\": \"4.0.0-alpha.14\" }, \"devDependencies\": { \"eslint-plugin-prettier\": \"3.0.1\", - \"postcss-overrides\": \"3.1.4\", - \"prettier\": \"1.17.0\", - \"prettier-stylelint\": \"0.4.2\" + \"prettier\": \"1.19.1\", + \"stylelint-config-idiomatic-order\": \"6.2.0\", + \"stylelint-config-prettier\": \"6.0.0\", + \"stylelint-prettier\": \"1.1.1\" }, \"resolutions\": { \"@plone/volto/razzle/webpack-dev-server\": \"3.2.0\" Note If you are linting activelly your project, the build might be broken after this update. You should run: $ yarn prettier:fix $ yarn stylelint:fix then commit the changes.","title":"Stylelint and prettier config in Alpha 14"},{"location":"upgrade-guide/#openobjectbrowser-api-change-in-alpha-11","text":"The API of the ObjectBrowser component changed in alpha 11 to make it more flexible. In case you had custom blocks using it, you have to update the call in case you were using a link mode: @@ -42,7 +42,7 @@ const OtherComp = ({ href: '', }); } - : () => openObjectBrowser('link') + : () => openObjectBrowser({ mode: 'link' }) } onChange={(name, value) => { onChangeBlock(block, { See the blocks section for more details.","title":"openObjectBrowser API change in Alpha 11"},{"location":"upgrade-guide/#renaming-tiles-into-blocks","text":"An internal renaming to use the term Blocks everywhere was done to unify naming through the code a and the documentation. Plone RESTAPI was updated to that purpose too, and running an upgrade step (do so in Plone's Addons control panel) is required in order to migrate the data. No step is required if you are using a brand new ZODB. This is the versions compatibility table across all the packages involved: Volto 4 - plone.restapi >= 5.0.0 - kitconcept.voltodemo >= 2.0 Note The renaming happened in Volto 4 alpha.10 and plone.restapi 5.0.0. Volto 4 alpha versions under that release use older versions of plone.restapi and kitconcept.voltodemo , however if you are using alpha releases it's recommended to upgrade to latest alpha or the final release of Volto 4. The project configuration should also be updated, in your src/config.js : diff --git a/src/config.js b/src/config.js index f1fe9c2..9517c38 100644 --- a/src/config.js +++ b/src/config.js @@ -16,7 +16,7 @@ import { settings as defaultSettings, views as defaultViews, widgets as defaultWidgets, - tiles as defaultTiles, + blocks as defaultBlocks, } from '@plone/volto/config'; export const settings = { @@ -31,6 +31,6 @@ export const widgets = { ...defaultWidgets, }; -export const tiles = { - ...defaultTiles, +export const blocks = { + ...defaultBlocks, };","title":"Renaming Tiles into Blocks"},{"location":"upgrade-guide/#add-theme-customization-to-your-project","text":"Volto 4 now also expects a file named src/theme.js with this content by default: import 'semantic-ui-less/semantic.less' ; import '@plone/volto/../theme/themes/pastanaga/extras/extras.less' ;","title":"Add theme customization to your project"},{"location":"upgrade-guide/#remove-enzyme-configuration","text":"Enzyme has been removed, in favor of @testing-library/react , and the configuration should be removed in package.json : diff --git a/package.json b/package.json index 27c7f8d..8f5f088 100644 --- a/package.json +++ b/package.json @@ -44,9 +44,6 @@ \"default\", \"jest-junit\" ], - \"snapshotSerializers\": [ - \"enzyme-to-json/serializer\" - ], \"transform\": { \"^.+\\\\.js(x)?$\": \"babel-jest\", \"^.+\\\\.css$\": \"jest-css-modules\",","title":"Remove enzyme configuration"},{"location":"upgrade-guide/#blocks-engine-blocks-configuration-object","text":"The blocks engine was updated and there are some important breaking changes, in case that you've developed custom blocks. The configuration object is now unified and expresses all the properties to model a block. This is how a block in the defaultBlocks object looks like: const defaultBlocks = { title : { id : 'title' , // The name (id) of the block title : 'Title' , // The display name of the block icon : titleSVG , // The icon used in the block chooser group : 'text' , // The group (blocks can be grouped, displayed in the chooser) view : ViewTitleBlock , // The view mode component edit : EditTitleBlock , // The edit mode component restricted : false , // If the block is restricted, it won't show in in the chooser mostUsed : false , // A meta group `most used`, appearing at the top of the chooser blockHasOwnFocusManagement : false , // Set this to true if the block manages its own focus security : { addPermission : [], // Future proof (not implemented yet) add user permission role(s) view : [], // Future proof (not implemented yet) view user role(s) }, }, ... There is an additional object groupBlocksOrder that contains an array with the order that the blocks group should appear: const groupBlocksOrder = [ { id : 'mostUsed' , title : 'Most used' }, { id : 'text' , title : 'Text' }, { id : 'media' , title : 'Media' }, { id : 'common' , title : 'Common' }, ]; You should adapt and merge the configuration of your own custom blocks to match the defaultBlocks and groupBlocksOrder one. You can modify the order of the groups and create your own as well.","title":"Blocks engine - Blocks configuration object"},{"location":"upgrade-guide/#blocks-engine-simplification-of-the-edit-blocks-wrapper","text":"The edit block wrapper boilerplate was quite big, and for bootstrap an edit block you had to copy it from an existing block. Now all this boilerplate has been transferred to the Blocks Engine, so bootstrapping the edit component of a block is easier and do not require any pre-existing code. In order to upgrade your blocks you should simplify the outter <div> (took as example the Title block): --- a/src/components/manage/Blocks/Title/Edit.jsx +++ b/src/components/manage/Blocks/Title/Edit.jsx @@ -138,11 +138,7 @@ class Edit extends Component { return <div />; } return ( - <div - role=\"presentation\" - onClick={() => this.props.onSelectBlock(this.props.block)} - className={cx('block title', { selected: this.props.selected })} - > + <> <Editor onChange={this.onChange} editorState={this.state.editorState} @@ -185,7 +181,7 @@ class Edit extends Component { this.node = node; }} /> - </div> + </> ); } } The blocks engine now takes care for the keyboard navigation of the blocks, so you need to remove the outter <div> from your custom block, then your block doesn't have to react to the change on this.props.selected either, because it's also something that the blocks engine already does for you. The focus management is also transferred to the engine, so no needed for your block to manage the focus. However, if your block does indeed require to manage its own focus, then you should mark it with the blockHasOwnFocusManagement property in the blocks configuration object: text : { id : 'text' , title : 'Text' , icon : textSVG , group : 'text' , view : ViewTextBlock , edit : EditTextBlock , restricted : false , mostUsed : false , blockHasOwnFocusManagement : true , security : { addPermission : [], view : [], }, },","title":"Blocks engine - Simplification of the edit blocks wrapper"},{"location":"upgrade-guide/#default-view-renaming","text":"The default view for content types DocumentView.jsx has been renamed to a more appropiate DefaultView.jsx . This view contains the code for rendering blocks in case the content type has been Blocks enabled. Enable Blocks on your content types by composing the view of your content type using DefaultView component.","title":"Default view renaming"},{"location":"upgrade-guide/#deprecations","text":"The old messages container has been removed since it's not used anymore by Volto. We changed it to use Toast library. Improve the Pastanaga Editor block wrapper container layout, deprecating the hack .ui.wrapper > * .","title":"Deprecations"},{"location":"upgrade-guide/#upgrading-to-volto-3x","text":"Volto was upgraded to use Razzle 3.0.0 which is not a breaking change itself, but it forces to some changes in the boilerplate on your Volto projects. You should change the babel config by deleting .babelrc file and creating a new file babel.config.js with these contents: module . exports = require ( '@plone/volto/babel' ); Then update your package.json to Volto 3.x. \"dependencies\" : { \"@plone/volto\" : \"3.0.0\" , ... } Volto 3.x is compatible with the new changes introduced in the vocabularies endpoint in plone.restapi 4.0.0. If you custom build a widget based in the Volto ones, you should update them as well. Volto updated its own widget set to support them: components/manage/Widgets/ArrayWidget components/manage/Widgets/SelectWidget components/manage/Widgets/TokenWidget They all use react-select third party library for render it.","title":"Upgrading to Volto 3.x"},{"location":"upgrade-guide/#upgrading-to-volto-2x","text":"","title":"Upgrading to Volto 2.x"},{"location":"upgrade-guide/#improved-blocks-hoc","text":"The Blocks HOC (High Order Component) was changed to lift off some of the features from the blocks themselves and now it takes care of them by its own. The delete block feature was moved to it The keylisteners for navigating through blocks was moved to it The properties passed down to the blocks are improved and documented This change only applies to your existing blocks, you have to update them accordingly by delete the trash icon and action from the end of your blocks { this . props . selected && ( < Button icon basic onClick = {() => this . props . onDeleteBlock ( this . props . block )} className = \"block-delete-button\" > < Icon name = { trashSVG } size = \"18px\" /> </ Button > )} Modify the parent element of your block making this changes: < div role = \"presentation\" onClick = {() => this . props . onSelectBlock ( this . props . block )} className = { cx ( 'block hero' , { selected : this . props . selected , })} tabIndex = { 0 } onKeyDown = { e => this . props . handleKeyDown ( e , this . props . index , this . props . block , this . node ) } ref = { node => { this . node = node ; }} > Add the keylisteners to the parent element of your block onKeyDown = { e => this . props . handleKeyDown ( e , this . props . index , this . props . block , this . node ) } Add a ref to it and assign it to this.node . ref = { node => { this . node = node ; }} Add a proper role for it role = \"presentation\" Take a look into the implementation of the default Volto blocks to get a grasp on all the edge cases related to keyboard navigation and how to deal with them.","title":"Improved Blocks HOC"},{"location":"upgrade-guide/#reordering-of-the-internal-css-added-an-extra","text":"The internal Volto CSS has been tidied up and reordered, for that reason, some other extras have been introduced and the theme.config in your project needs to be updated by making sure you have these two extras in the theme.config file: /* Extras */ @main : 'pastanaga' ; @custom : 'pastanaga' ;","title":"Reordering of the internal CSS, added an extra"}]}